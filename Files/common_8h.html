<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>common.h - Crelude Documentation</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Documentation for Crelude, the C prelude/standard-library.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> Documentation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Classes/index.html"><strong aria-hidden="true">1.1.</strong> Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Classes/structsymbol.html"><strong aria-hidden="true">1.1.1.</strong> symbol</a></li><li class="chapter-item expanded "><a href="../Classes/structStringBuilder.html"><strong aria-hidden="true">1.1.2.</strong> StringBuilder</a></li><li class="chapter-item expanded "><a href="../Classes/structstring.html"><strong aria-hidden="true">1.1.3.</strong> string</a></li><li class="chapter-item expanded "><a href="../Classes/structRunicBuilder.html"><strong aria-hidden="true">1.1.4.</strong> RunicBuilder</a></li><li class="chapter-item expanded "><a href="../Classes/structrunic.html"><strong aria-hidden="true">1.1.5.</strong> runic</a></li><li class="chapter-item expanded "><a href="../Classes/structMemSlice.html"><strong aria-hidden="true">1.1.6.</strong> MemSlice</a></li><li class="chapter-item expanded "><a href="../Classes/structMemArray.html"><strong aria-hidden="true">1.1.7.</strong> MemArray</a></li><li class="chapter-item expanded "><a href="../Classes/structGenericSlice.html"><strong aria-hidden="true">1.1.8.</strong> GenericSlice</a></li><li class="chapter-item expanded "><a href="../Classes/structGenericMap.html"><strong aria-hidden="true">1.1.9.</strong> GenericMap</a></li><li class="chapter-item expanded "><a href="../Classes/structGenericArray.html"><strong aria-hidden="true">1.1.10.</strong> GenericArray</a></li><li class="chapter-item expanded "><a href="../Classes/structArgs.html"><strong aria-hidden="true">1.1.11.</strong> Args</a></li><li class="chapter-item expanded "><a href="../Classes/struct__Natural.html"><strong aria-hidden="true">1.1.12.</strong> _Natural</a></li><li class="chapter-item expanded "><a href="../Classes/struct__atomic__t.html"><strong aria-hidden="true">1.1.13.</strong> _atomic_t</a></li><li class="chapter-item expanded "><a href="../Classes/struct__ArgTemplate.html"><strong aria-hidden="true">1.1.14.</strong> _ArgTemplate</a></li><li class="chapter-item expanded "><a href="../Classes/struct__ArgParser.html"><strong aria-hidden="true">1.1.15.</strong> _ArgParser</a></li><li class="chapter-item expanded "><a href="../Classes/struct__ArgID.html"><strong aria-hidden="true">1.1.16.</strong> _ArgID</a></li><li class="chapter-item expanded "><a href="../Classes/struct__Arg.html"><strong aria-hidden="true">1.1.17.</strong> _Arg</a></li></ol></li><li class="chapter-item expanded "><a href="../Files/index.html"><strong aria-hidden="true">1.2.</strong> Files</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Files/dir_68267d1309a1af8e8297ef4c3efbcdba.html"><strong aria-hidden="true">1.2.1.</strong> src</a></li><li class="chapter-item expanded "><a href="../Files/dir_21e32e04f18f8d48a02ea1aac13d6f2b.html"><strong aria-hidden="true">1.2.2.</strong> src/crelude</a></li><li class="chapter-item expanded "><a href="../Files/argparse_8c.html"><strong aria-hidden="true">1.2.3.</strong> argparse.c</a></li><li class="chapter-item expanded "><a href="../Files/argparse_8h.html"><strong aria-hidden="true">1.2.4.</strong> argparse.h</a></li><li class="chapter-item expanded "><a href="../Files/base64_8c.html"><strong aria-hidden="true">1.2.5.</strong> base64.c</a></li><li class="chapter-item expanded "><a href="../Files/base64_8h.html"><strong aria-hidden="true">1.2.6.</strong> base64.h</a></li><li class="chapter-item expanded "><a href="../Files/common_8c.html"><strong aria-hidden="true">1.2.7.</strong> common.c</a></li><li class="chapter-item expanded "><a href="../Files/common_8h.html" class="active"><strong aria-hidden="true">1.2.8.</strong> common.h</a></li><li class="chapter-item expanded "><a href="../Files/io_8c.html"><strong aria-hidden="true">1.2.9.</strong> io.c</a></li><li class="chapter-item expanded "><a href="../Files/io_8h.html"><strong aria-hidden="true">1.2.10.</strong> io.h</a></li><li class="chapter-item expanded "><a href="../Files/log_8h.html"><strong aria-hidden="true">1.2.11.</strong> log.h</a></li><li class="chapter-item expanded "><a href="../Files/utf_8c.html"><strong aria-hidden="true">1.2.12.</strong> utf.c</a></li><li class="chapter-item expanded "><a href="../Files/utf_8h.html"><strong aria-hidden="true">1.2.13.</strong> utf.h</a></li><li class="chapter-item expanded "><a href="../Files/tests_8c.html"><strong aria-hidden="true">1.2.14.</strong> tests.c</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Crelude Documentation</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <hr />
<p>title: src/crelude/common.h</p>
<hr />
<h1 id="srccreludecommonh"><a class="header" href="#srccreludecommonh">src/crelude/common.h</a></h1>
<p><a href="#detailed-description">More...</a></p>
<h2 id="classes"><a class="header" href="#classes">Classes</a></h2>
<div class="table-wrapper"><table><thead><tr><th></th><th>Name</th></tr></thead><tbody>
<tr><td>struct</td><td><strong><a href="/crelude/Classes/struct__atomic__t.html">_atomic_t</a></strong> <br>Useful for resource counting etc.</td></tr>
<tr><td>struct</td><td><strong><a href="/crelude/Classes/structGenericArray.html">GenericArray</a></strong> <br>Array with pointer to void.</td></tr>
<tr><td>struct</td><td><strong><a href="/crelude/Classes/structMemArray.html">MemArray</a></strong> <br>Array with pointer type to smallest addressable units of memory.</td></tr>
<tr><td>struct</td><td><strong><a href="/crelude/Classes/structGenericSlice.html">GenericSlice</a></strong> <br>Slice with pointer to void.</td></tr>
<tr><td>struct</td><td><strong><a href="/crelude/Classes/structMemSlice.html">MemSlice</a></strong> <br>Slice with pointer type to smallest addressable units of memory.</td></tr>
<tr><td>struct</td><td><strong><a href="/crelude/Classes/structGenericMap.html">GenericMap</a></strong> <br>Hash-table that maps <code>void *</code> to <code>void *</code>.</td></tr>
<tr><td>struct</td><td><strong><a href="/crelude/Classes/structstring.html">string</a></strong> <br>Immutable wrapper for UTF-8 encoded string (bytes are mutable).</td></tr>
<tr><td>struct</td><td><strong><a href="/crelude/Classes/structrunic.html">runic</a></strong> <br>Imutable warpper for UCS-4/UTF-32 encoded runic string (runes are mutable).</td></tr>
<tr><td>struct</td><td><strong><a href="/crelude/Classes/structStringBuilder.html">StringBuilder</a></strong> <br>Mutable string which is built/pushed-to over time.</td></tr>
<tr><td>struct</td><td><strong><a href="/crelude/Classes/structRunicBuilder.html">RunicBuilder</a></strong> <br>Mutable runic string which is built/pushed-to over time.</td></tr>
<tr><td>struct</td><td><strong><a href="/crelude/Classes/structsymbol.html">symbol</a></strong> <br>Symbols are interned strings.</td></tr>
</tbody></table>
</div>
<h2 id="types"><a class="header" href="#types">Types</a></h2>
<div class="table-wrapper"><table><thead><tr><th></th><th>Name</th></tr></thead><tbody>
<tr><td>enum</td><td><strong><a href="/crelude/Files/common_8h.html#enum-hashkeytype">HashKeyType</a></strong> { HKT_STRING = 1 &lt;&lt; 0, HKT_RUNIC = 1 &lt;&lt; 1, HKT_CSTRING = 1 &lt;&lt; 2, HKT_MEM_SLICE = 1 &lt;&lt; 3, HKT_RAW_BYTES = 1 &lt;&lt; 4, HKT_SMALL_INTEGER = 1 &lt;&lt; 5}</td></tr>
<tr><td>typedef enum <a href="/crelude/Files/common_8h.html#enum-hashkeytype">HashKeyType</a></td><td><strong><a href="/crelude/Files/common_8h.html#typedef-hashkeytype">HashKeyType</a></strong></td></tr>
<tr><td>typedef struct <a href="/crelude/Classes/struct__atomic__t.html">_atomic_t</a></td><td><strong><a href="/crelude/Files/common_8h.html#typedef-atomic_t">atomic_t</a></strong> <br>Useful for resource counting etc.</td></tr>
<tr><td>typedef void</td><td><strong><a href="/crelude/Files/common_8h.html#typedef-u0">u0</a></strong></td></tr>
<tr><td>typedef signed int</td><td><strong><a href="/crelude/Files/common_8h.html#typedef-ierr">ierr</a></strong></td></tr>
<tr><td>typedef unsigned int</td><td><strong><a href="/crelude/Files/common_8h.html#typedef-uerr">uerr</a></strong></td></tr>
<tr><td>typedef unsigned long</td><td><strong><a href="/crelude/Files/common_8h.html#typedef-uword">uword</a></strong> <br><code>long</code> is always the same size as a machine word.</td></tr>
<tr><td>typedef signed long</td><td><strong><a href="/crelude/Files/common_8h.html#typedef-iword">iword</a></strong></td></tr>
<tr><td>typedef unsigned int</td><td><strong><a href="/crelude/Files/common_8h.html#typedef-ufast">ufast</a></strong></td></tr>
<tr><td>typedef signed int</td><td><strong><a href="/crelude/Files/common_8h.html#typedef-ifast">ifast</a></strong></td></tr>
<tr><td>typedef ptrdiff_t</td><td><strong><a href="/crelude/Files/common_8h.html#typedef-isize">isize</a></strong></td></tr>
<tr><td>typedef size_t</td><td><strong><a href="/crelude/Files/common_8h.html#typedef-usize">usize</a></strong> <br>Use for storing array indices or object sizes.</td></tr>
<tr><td>typedef intptr_t</td><td><strong><a href="/crelude/Files/common_8h.html#typedef-iptr">iptr</a></strong></td></tr>
<tr><td>typedef uintptr_t</td><td><strong><a href="/crelude/Files/common_8h.html#typedef-uptr">uptr</a></strong> <br>Large enough to store a pointer, like (void *).</td></tr>
<tr><td>typedef intmax_t</td><td><strong><a href="/crelude/Files/common_8h.html#typedef-imax">imax</a></strong></td></tr>
<tr><td>typedef uintmax_t</td><td><strong><a href="/crelude/Files/common_8h.html#typedef-umax">umax</a></strong></td></tr>
<tr><td>typedef unsigned char</td><td><strong><a href="/crelude/Files/common_8h.html#typedef-umin">umin</a></strong> <br>Such that <code>sizeof(umin) == 1</code>.</td></tr>
<tr><td>typedef signed char</td><td><strong><a href="/crelude/Files/common_8h.html#typedef-imin">imin</a></strong> <br>Such that <code>sizeof(imin) == 1</code>.</td></tr>
<tr><td>typedef __int8_t</td><td><strong><a href="/crelude/Files/common_8h.html#typedef-i8">i8</a></strong></td></tr>
<tr><td>typedef __uint8_t</td><td><strong><a href="/crelude/Files/common_8h.html#typedef-u8">u8</a></strong></td></tr>
<tr><td>typedef __uint8_t</td><td><strong><a href="/crelude/Files/common_8h.html#typedef-byte">byte</a></strong> <br>Don't use <code>char</code> when you want <code>byte</code>.</td></tr>
<tr><td>typedef __int16_t</td><td><strong><a href="/crelude/Files/common_8h.html#typedef-i16">i16</a></strong></td></tr>
<tr><td>typedef __uint16_t</td><td><strong><a href="/crelude/Files/common_8h.html#typedef-u16">u16</a></strong></td></tr>
<tr><td>typedef __int32_t</td><td><strong><a href="/crelude/Files/common_8h.html#typedef-i32">i32</a></strong></td></tr>
<tr><td>typedef __uint32_t</td><td><strong><a href="/crelude/Files/common_8h.html#typedef-u32">u32</a></strong></td></tr>
<tr><td>typedef <a href="/crelude/Files/common_8h.html#typedef-u32">u32</a></td><td><strong><a href="/crelude/Files/common_8h.html#typedef-rune">rune</a></strong></td></tr>
<tr><td>typedef __int64_t</td><td><strong><a href="/crelude/Files/common_8h.html#typedef-i64">i64</a></strong></td></tr>
<tr><td>typedef __uint64_t</td><td><strong><a href="/crelude/Files/common_8h.html#typedef-u64">u64</a></strong></td></tr>
</tbody></table>
</div>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th></th><th>Name</th></tr></thead><tbody>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#function-_static_assert">_Static_assert</a></strong>(sizeof(<a href="/crelude/Files/common_8h.html#typedef-umin">umin</a>)  ==1 &amp;&amp;sizeof(<a href="/crelude/Files/common_8h.html#typedef-imin">imin</a>)==1, &quot;<code>umin</code> and <code>[imin](/crelude/Files/common_8h.md#typedef-imin)</code> must have <a href="/crelude/Files/common_8h.html#variable-size">size</a> one (1).&quot; )</td></tr>
<tr><td><a href="/crelude/Files/common_8h.html#typedef-u0">u0</a></td><td><strong><a href="/crelude/Files/common_8h.html#function-panic">panic</a></strong>(const <a href="/crelude/Files/common_8h.html#typedef-byte">byte</a> * , ... )</td></tr>
<tr><td><a href="/crelude/Files/common_8h.html#typedef-u0">u0</a> *</td><td><strong><a href="/crelude/Files/common_8h.html#function-or">or</a></strong>(const <a href="/crelude/Files/common_8h.html#typedef-u0">u0</a> * nullable, const <a href="/crelude/Files/common_8h.html#typedef-u0">u0</a> * nonnull)</td></tr>
<tr><td>bool</td><td><strong><a href="/crelude/Files/common_8h.html#function-is_zero">is_zero</a></strong>(<a href="/crelude/Files/common_8h.html#typedef-imax">imax</a> )</td></tr>
<tr><td>bool</td><td><strong><a href="/crelude/Files/common_8h.html#function-is_zerof">is_zerof</a></strong>(f64 )</td></tr>
<tr><td>bool</td><td><strong><a href="/crelude/Files/common_8h.html#function-is_zeroed">is_zeroed</a></strong>(<a href="/crelude/Files/common_8h.html#typedef-u0">u0</a> * , <a href="/crelude/Files/common_8h.html#typedef-usize">usize</a> )</td></tr>
<tr><td><a href="/crelude/Files/common_8h.html#typedef-u0">u0</a></td><td><strong><a href="/crelude/Files/common_8h.html#function-zero">zero</a></strong>(<a href="/crelude/Files/common_8h.html#typedef-u0">u0</a> * blk, <a href="/crelude/Files/common_8h.html#typedef-usize">usize</a> width)</td></tr>
<tr><td><a href="/crelude/Files/common_8h.html#typedef-u0">u0</a> *</td><td><strong><a href="/crelude/Files/common_8h.html#function-emalloc">emalloc</a></strong>(<a href="/crelude/Files/common_8h.html#typedef-usize">usize</a> , <a href="/crelude/Files/common_8h.html#typedef-usize">usize</a> )<br>Malloc with zeros, and panics when out of memory.</td></tr>
<tr><td><a href="/crelude/Files/common_8h.html#typedef-u0">u0</a></td><td><strong><a href="/crelude/Files/common_8h.html#function-reverse">reverse</a></strong>(<a href="/crelude/Files/common_8h.html#typedef-u0">u0</a> * self, <a href="/crelude/Files/common_8h.html#typedef-usize">usize</a> width)</td></tr>
<tr><td><a href="/crelude/Classes/structMemSlice.html">MemSlice</a></td><td><strong><a href="/crelude/Files/common_8h.html#function-reverse_endianness">reverse_endianness</a></strong>(<a href="/crelude/Classes/structMemSlice.html">MemSlice</a> bytes)</td></tr>
<tr><td>bool</td><td><strong><a href="/crelude/Files/common_8h.html#function-is_little_endian">is_little_endian</a></strong>(void )</td></tr>
<tr><td>u128</td><td><strong><a href="/crelude/Files/common_8h.html#function-big_endian">big_endian</a></strong>(<a href="/crelude/Files/common_8h.html#typedef-umin">umin</a> * start, <a href="/crelude/Files/common_8h.html#typedef-usize">usize</a> bytes)<br>Read big-endian integer.</td></tr>
<tr><td><a href="/crelude/Files/common_8h.html#typedef-u0">u0</a></td><td><strong><a href="/crelude/Files/common_8h.html#function-swap">swap</a></strong>(<a href="/crelude/Files/common_8h.html#typedef-u0">u0</a> * self, <a href="/crelude/Files/common_8h.html#typedef-usize">usize</a> pivot, <a href="/crelude/Files/common_8h.html#typedef-usize">usize</a> width)</td></tr>
<tr><td><a href="/crelude/Files/common_8h.html#typedef-u0">u0</a></td><td><strong><a href="/crelude/Files/common_8h.html#function-memswap">memswap</a></strong>(<a href="/crelude/Files/common_8h.html#typedef-umin">umin</a> * a, <a href="/crelude/Files/common_8h.html#typedef-umin">umin</a> * b, <a href="/crelude/Files/common_8h.html#typedef-usize">usize</a> bytes)</td></tr>
<tr><td><a href="/crelude/Files/common_8h.html#typedef-usize">usize</a></td><td><strong><a href="/crelude/Files/common_8h.html#function-resize">resize</a></strong>(<a href="/crelude/Files/common_8h.html#typedef-u0">u0</a> * self, <a href="/crelude/Files/common_8h.html#typedef-usize">usize</a> cap, <a href="/crelude/Files/common_8h.html#typedef-usize">usize</a> width)</td></tr>
<tr><td><a href="/crelude/Files/common_8h.html#typedef-usize">usize</a></td><td><strong><a href="/crelude/Files/common_8h.html#function-grow">grow</a></strong>(<a href="/crelude/Files/common_8h.html#typedef-u0">u0</a> * self, <a href="/crelude/Files/common_8h.html#typedef-usize">usize</a> count, <a href="/crelude/Files/common_8h.html#typedef-usize">usize</a> width)</td></tr>
<tr><td><a href="/crelude/Files/common_8h.html#typedef-u0">u0</a> *</td><td><strong><a href="/crelude/Files/common_8h.html#function-get">get</a></strong>(<a href="/crelude/Files/common_8h.html#typedef-u0">u0</a> * self, <a href="/crelude/Files/common_8h.html#typedef-usize">usize</a> index, <a href="/crelude/Files/common_8h.html#typedef-usize">usize</a> width)</td></tr>
<tr><td><a href="/crelude/Files/common_8h.html#typedef-u0">u0</a> *</td><td><strong><a href="/crelude/Files/common_8h.html#function-set">set</a></strong>(<a href="/crelude/Files/common_8h.html#typedef-u0">u0</a> * self, <a href="/crelude/Files/common_8h.html#typedef-usize">usize</a> index, const <a href="/crelude/Files/common_8h.html#typedef-u0">u0</a> * elem, <a href="/crelude/Files/common_8h.html#typedef-usize">usize</a> width)</td></tr>
<tr><td><a href="/crelude/Files/common_8h.html#typedef-usize">usize</a></td><td><strong><a href="/crelude/Files/common_8h.html#function-push">push</a></strong>(<a href="/crelude/Files/common_8h.html#typedef-u0">u0</a> * self, const <a href="/crelude/Files/common_8h.html#typedef-u0">u0</a> * element, <a href="/crelude/Files/common_8h.html#typedef-usize">usize</a> width)</td></tr>
<tr><td><a href="/crelude/Files/common_8h.html#typedef-u0">u0</a> *</td><td><strong><a href="/crelude/Files/common_8h.html#function-pop">pop</a></strong>(<a href="/crelude/Files/common_8h.html#typedef-u0">u0</a> * self, <a href="/crelude/Files/common_8h.html#typedef-usize">usize</a> width)</td></tr>
<tr><td><a href="/crelude/Files/common_8h.html#typedef-u0">u0</a> *</td><td><strong><a href="/crelude/Files/common_8h.html#function-shift">shift</a></strong>(<a href="/crelude/Files/common_8h.html#typedef-u0">u0</a> * self, <a href="/crelude/Files/common_8h.html#typedef-usize">usize</a> width)<br>Works like <code>pop</code> but removes from the front.</td></tr>
<tr><td><a href="/crelude/Files/common_8h.html#typedef-usize">usize</a></td><td><strong><a href="/crelude/Files/common_8h.html#function-insert">insert</a></strong>(<a href="/crelude/Files/common_8h.html#typedef-u0">u0</a> * self, <a href="/crelude/Files/common_8h.html#typedef-usize">usize</a> index, const <a href="/crelude/Files/common_8h.html#typedef-u0">u0</a> * element, <a href="/crelude/Files/common_8h.html#typedef-usize">usize</a> width)</td></tr>
<tr><td><a href="/crelude/Files/common_8h.html#typedef-usize">usize</a></td><td><strong><a href="/crelude/Files/common_8h.html#function-extend">extend</a></strong>(<a href="/crelude/Files/common_8h.html#typedef-u0">u0</a> * self, const <a href="/crelude/Files/common_8h.html#typedef-u0">u0</a> * slice, <a href="/crelude/Files/common_8h.html#typedef-usize">usize</a> width)</td></tr>
<tr><td><a href="/crelude/Files/common_8h.html#typedef-usize">usize</a></td><td><strong><a href="/crelude/Files/common_8h.html#function-splice">splice</a></strong>(<a href="/crelude/Files/common_8h.html#typedef-u0">u0</a> * self, <a href="/crelude/Files/common_8h.html#typedef-usize">usize</a> index, const <a href="/crelude/Files/common_8h.html#typedef-u0">u0</a> * slice, <a href="/crelude/Files/common_8h.html#typedef-usize">usize</a> width)</td></tr>
<tr><td><a href="/crelude/Classes/structGenericSlice.html">GenericSlice</a></td><td><strong><a href="/crelude/Files/common_8h.html#function-cut">cut</a></strong>(<a href="/crelude/Files/common_8h.html#typedef-u0">u0</a> * self, <a href="/crelude/Files/common_8h.html#typedef-usize">usize</a> from, <a href="/crelude/Files/common_8h.html#typedef-isize">isize</a> upto, <a href="/crelude/Files/common_8h.html#typedef-usize">usize</a> width)</td></tr>
<tr><td><a href="/crelude/Files/common_8h.html#typedef-usize">usize</a></td><td><strong><a href="/crelude/Files/common_8h.html#function-null">null</a></strong>(<a href="/crelude/Files/common_8h.html#typedef-u0">u0</a> * self, <a href="/crelude/Files/common_8h.html#typedef-usize">usize</a> width)</td></tr>
<tr><td><a href="/crelude/Classes/structstring.html">string</a></td><td><strong><a href="/crelude/Files/common_8h.html#function-from_cstring">from_cstring</a></strong>(const <a href="/crelude/Files/common_8h.html#typedef-byte">byte</a> * )<br>NUL-terminated string to library string.</td></tr>
<tr><td>bool</td><td><strong><a href="/crelude/Files/common_8h.html#function-string_eq">string_eq</a></strong>(const string, const string)<br>Compare two strings for equality.</td></tr>
<tr><td><a href="/crelude/Files/common_8h.html#typedef-i16">i16</a></td><td><strong><a href="/crelude/Files/common_8h.html#function-string_cmp">string_cmp</a></strong>(const string, const string)<br>Compare two strings for alphabetic rank.</td></tr>
<tr><td><a href="/crelude/Files/common_8h.html#typedef-i16">i16</a></td><td><strong><a href="/crelude/Files/common_8h.html#function-string_ncmp">string_ncmp</a></strong>(const string, const string, <a href="/crelude/Files/common_8h.html#typedef-usize">usize</a> n)<br>Compare two strings for alphabetic rank upto a given number of bytes.</td></tr>
<tr><td><a href="/crelude/Files/common_8h.html#typedef-u64">u64</a></td><td><strong><a href="/crelude/Files/common_8h.html#function-hash_string">hash_string</a></strong>(const string)<br>Hash a string.</td></tr>
<tr><td><a href="/crelude/Files/common_8h.html#typedef-u64">u64</a></td><td><strong><a href="/crelude/Files/common_8h.html#function-hash_bytes">hash_bytes</a></strong>(const MemSlice)<br>Hash a byte slice.</td></tr>
<tr><td><a href="/crelude/Files/common_8h.html#typedef-u0">u0</a></td><td><strong><a href="/crelude/Files/common_8h.html#function-associate">associate</a></strong>(<a href="/crelude/Files/common_8h.html#typedef-u0">u0</a> * self, const <a href="/crelude/Files/common_8h.html#typedef-u0">u0</a> * key, const <a href="/crelude/Files/common_8h.html#typedef-u0">u0</a> * value)<br>Map / associate a key with a value, i.e. insert into the hash-map/table.</td></tr>
<tr><td><a href="/crelude/Files/common_8h.html#typedef-u0">u0</a> *</td><td><strong><a href="/crelude/Files/common_8h.html#function-lookup">lookup</a></strong>(<a href="/crelude/Files/common_8h.html#typedef-u0">u0</a> * self, const <a href="/crelude/Files/common_8h.html#typedef-u0">u0</a> * key)<br>Look-up / get value from hash-map/table given the key.</td></tr>
<tr><td>bool</td><td><strong><a href="/crelude/Files/common_8h.html#function-drop">drop</a></strong>(<a href="/crelude/Files/common_8h.html#typedef-u0">u0</a> * self, const <a href="/crelude/Files/common_8h.html#typedef-u0">u0</a> * key)</td></tr>
<tr><td><a href="/crelude/Classes/structGenericSlice.html">GenericSlice</a></td><td><strong><a href="/crelude/Files/common_8h.html#function-get_keys">get_keys</a></strong>(<a href="/crelude/Files/common_8h.html#typedef-u0">u0</a> * self)</td></tr>
<tr><td>bool</td><td><strong><a href="/crelude/Files/common_8h.html#function-has_key">has_key</a></strong>(<a href="/crelude/Files/common_8h.html#typedef-u0">u0</a> * self, <a href="/crelude/Files/common_8h.html#typedef-u0">u0</a> * key)<br>Checks if entry / key-value pair is present in hash-table/map given a key.</td></tr>
<tr><td><a href="/crelude/Files/common_8h.html#typedef-u0">u0</a></td><td><strong><a href="/crelude/Files/common_8h.html#function-empty_map">empty_map</a></strong>(<a href="/crelude/Files/common_8h.html#typedef-u0">u0</a> * self)</td></tr>
<tr><td>bool</td><td><strong><a href="/crelude/Files/common_8h.html#function-is_empty_map">is_empty_map</a></strong>(<a href="/crelude/Files/common_8h.html#typedef-u0">u0</a> * self)<br>Checks if the hash-table / map is empty or freed.</td></tr>
<tr><td><a href="/crelude/Files/common_8h.html#typedef-u0">u0</a></td><td><strong><a href="/crelude/Files/common_8h.html#function-free_map">free_map</a></strong>(<a href="/crelude/Files/common_8h.html#typedef-u0">u0</a> * self)</td></tr>
<tr><td><a href="/crelude/Files/common_8h.html#typedef-usize">usize</a></td><td><strong><a href="/crelude/Files/common_8h.html#function-init_hashnode">init_hashnode</a></strong>(<a href="/crelude/Files/common_8h.html#typedef-u0">u0</a> * , const <a href="/crelude/Files/common_8h.html#typedef-u0">u0</a> * , <a href="/crelude/Files/common_8h.html#typedef-u64">u64</a> , const <a href="/crelude/Files/common_8h.html#typedef-u0">u0</a> * , const <a href="/crelude/Files/common_8h.html#typedef-u0">u0</a> * )<br>Internal use 99% of the time.</td></tr>
<tr><td><a href="/crelude/Files/common_8h.html#typedef-u0">u0</a></td><td><strong><a href="/crelude/Files/common_8h.html#function-dump_hashmap">dump_hashmap</a></strong>(<a href="/crelude/Files/common_8h.html#typedef-u0">u0</a> * self, <a href="/crelude/Files/common_8h.html#typedef-byte">byte</a> * key_formatter, <a href="/crelude/Files/common_8h.html#typedef-byte">byte</a> * value_formatter)<br>Hashmap debugging function.</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#function-__attribute__"><strong>attribute</strong></a></strong>((unused) ) const</td></tr>
<tr><td>return</td><td><strong><a href="/crelude/Files/common_8h.html#function-hash_bytes">hash_bytes</a></strong>(<strong>extension</strong>({ __auto_type _self=(<a href="/crelude/Files/common_8h.html#variable-runes">runes</a>);<a href="/crelude/Classes/structMemSlice.html">MemSlice</a> _bytes={ .<a href="/crelude/Files/base64_8h.html#variable-len">len</a>=<a href="/crelude/Files/base64_8h.html#variable-len">_self.len</a> <em>sizeof(</em><a href="/crelude/Files/common_8h.html#variable-value">_self.value</a>),.<a href="/crelude/Files/common_8h.html#variable-value">value</a>=(<a href="/crelude/Files/common_8h.html#typedef-umin">umin</a> *) <a href="/crelude/Files/common_8h.html#variable-value">_self.value</a> };_bytes;}) )</td></tr>
<tr><td>return</td><td><strong><a href="/crelude/Files/common_8h.html#function-hash_string">hash_string</a></strong>(<a href="/crelude/Files/common_8h.html#function-from_cstring">from_cstring</a>(*(<a href="/crelude/Files/common_8h.html#typedef-byte">byte</a> **) <a href="/crelude/Files/common_8h.html#variable-key">key</a>) )</td></tr>
</tbody></table>
</div>
<h2 id="attributes"><a class="header" href="#attributes">Attributes</a></h2>
<div class="table-wrapper"><table><thead><tr><th></th><th>Name</th></tr></thead><tbody>
<tr><td><a href="/crelude/Files/common_8h.html#typedef-u64">u64</a></td><td><strong><a href="/crelude/Files/common_8h.html#variable-hash">hash</a></strong></td></tr>
<tr><td><a href="/crelude/Files/common_8h.html#typedef-u0">u0</a> *</td><td><strong><a href="/crelude/Files/common_8h.html#variable-value">value</a></strong></td></tr>
<tr><td>struct @21</td><td><strong><a href="/crelude/Files/common_8h.html#variable-key">key</a></strong></td></tr>
<tr><td><a href="/crelude/Files/common_8h.html#typedef-u0">u0</a> *</td><td><strong><a href="/crelude/Files/common_8h.html#variable-next">next</a></strong></td></tr>
<tr><td>const <a href="/crelude/Files/common_8h.html#typedef-ierr">ierr</a></td><td><strong><a href="/crelude/Files/common_8h.html#variable-nul">NUL</a></strong></td></tr>
<tr><td>const <a href="/crelude/Files/common_8h.html#typedef-byte">byte</a></td><td><strong><a href="/crelude/Files/common_8h.html#variable-nul_byte">NUL_BYTE</a></strong></td></tr>
<tr><td>const <a href="/crelude/Classes/structstring.html">string</a></td><td><strong><a href="/crelude/Files/common_8h.html#variable-nul_string">NUL_STRING</a></strong></td></tr>
<tr><td>const <a href="/crelude/Files/common_8h.html#typedef-iword">iword</a></td><td><strong><a href="/crelude/Files/common_8h.html#variable-zero">ZERO</a></strong></td></tr>
<tr><td><a href="/crelude/Files/common_8h.html#typedef-usize">usize</a></td><td><strong><a href="/crelude/Files/common_8h.html#variable-_">_</a></strong></td></tr>
<tr><td><a href="/crelude/Classes/structrunic.html">runic</a></td><td><strong><a href="/crelude/Files/common_8h.html#variable-runes">runes</a></strong></td></tr>
<tr><td><a href="/crelude/Files/common_8h.html#typedef-usize">usize</a></td><td><strong><a href="/crelude/Files/common_8h.html#variable-size">size</a></strong></td></tr>
</tbody></table>
</div>
<h2 id="defines"><a class="header" href="#defines">Defines</a></h2>
<div class="table-wrapper"><table><thead><tr><th></th><th>Name</th></tr></thead><tbody>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-_gnu_source">_GNU_SOURCE</a></strong> <br>Use GNU specific source.</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-free">FREE</a></strong></td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-malloc">MALLOC</a></strong></td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-realloc">REALLOC</a></strong></td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-va_num_args_impl">VA_NUM_ARGS_IMPL</a></strong>(_1, _2, _3, _4, _5, N, ...)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-va_num_args">VA_NUM_ARGS</a></strong>(...)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-_tstr">_TSTR</a></strong>(x)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-tstr">TSTR</a></strong>(x)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-todo">TODO</a></strong>(...)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-crelude_v_major">crelude_V_MAJOR</a></strong></td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-crelude_v_minor">crelude_V_MINOR</a></strong></td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-crelude_v_patch">crelude_V_PATCH</a></strong></td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-crelude_version">crelude_VERSION</a></strong></td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-array_realloc_factor">ARRAY_REALLOC_FACTOR</a></strong></td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-loop">loop</a></strong></td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-whilst">whilst</a></strong></td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-unless">unless</a></strong>(cond)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-never">never</a></strong></td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-always">always</a></strong></td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-until">until</a></strong>(cond)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-unqualify">unqualify</a></strong>(D, T)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-record">record</a></strong>(NAME)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-enumerable">enumerable</a></strong>(NAME)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-overlap">overlap</a></strong>(NAME)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-newtype">newtype</a></strong>(NT, T)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-arrayof">arrayof</a></strong>(T)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-newarray">newarray</a></strong>(NT, T)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-sliceof">sliceof</a></strong>(T)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-newslice">newslice</a></strong>(NT, T)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-hashof">hashof</a></strong>(T)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-newhashable">newhashable</a></strong>(NT, T)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-hashmap_load_threshold">HASHMAP_LOAD_THRESHOLD</a></strong></td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-hashmap_growth_factor">HASHMAP_GROWTH_FACTOR</a></strong></td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-newmap">newmap</a></strong>(NT, K, V)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-mapof">mapof</a></strong>(K, V)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-hashnode">hashnode</a></strong>(K, V)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-mmake">MMAKE</a></strong>(K, V, CAP)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-mnew">MNEW</a></strong>(VARIABLE, CAP) <br>Create new map / initialise map from map variable.</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-nth">NTH</a></strong>(LIST, N)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-get">GET</a></strong>(LIST, N)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-set">SET</a></strong>(LIST, N, V)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-unused1">UNUSED1</a></strong>(z)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-unused2">UNUSED2</a></strong>(y, z)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-unused3">UNUSED3</a></strong>(x, y, z)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-unused4">UNUSED4</a></strong>(b, x, y, z)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-unused5">UNUSED5</a></strong>(a, b, x, y, z)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-unused_impl_">UNUSED_IMPL_</a></strong>(nargs)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-unused_impl">UNUSED_IMPL</a></strong>(nargs)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-unused">UNUSED</a></strong>(...)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-no_error">NO_ERROR</a></strong></td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-ok">OK</a></strong></td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-okay">OKAY</a></strong></td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-fail">FAIL</a></strong></td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-noop">NOOP</a></strong></td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-nil">nil</a></strong></td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-floor">FLOOR</a></strong>(T, N)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-ceil">CEIL</a></strong>(T, N)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-unit">UNIT</a></strong></td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-word_size">WORD_SIZE</a></strong> <br>Size of a machine word in bytes.</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-__uchar8__"><strong>UCHAR8</strong></a></strong></td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-__uchar8__"><strong>UCHAR8</strong></a></strong></td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-_float_bit">_FLOAT_BIT</a></strong></td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-_double_bit">_DOUBLE_BIT</a></strong></td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-_ldouble_bit">_LDOUBLE_BIT</a></strong></td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-copy">COPY</a></strong>(SELF)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-to_bytes">TO_BYTES</a></strong>(SELF) <br>Convert array/slice to slice of bytes.</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-from_bytes">FROM_BYTES</a></strong>(T, SELF) <br>Convert from a byte array/slice into an array/slice of another type.</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-reverse">REVERSE</a></strong>(SELF) <br>In-place reverse.</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-swap">SWAP</a></strong>(SELF, PIVOT)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-push">PUSH</a></strong>(SELF, ELEM)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-pop">POP</a></strong>(SELF)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-shift">SHIFT</a></strong>(SELF)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-insert">INSERT</a></strong>(SELF, INDEX, ELEM)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-extend">EXTEND</a></strong>(SELF, SLIC)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-splice">SPLICE</a></strong>(SELF, INDEX, SLIC)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-cut">CUT</a></strong>(SELF, FROM, UPTO)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-remove">REMOVE</a></strong>(SELF, INDEX)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-associate">ASSOCIATE</a></strong>(SELF, KEY, VAL)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-lookup">LOOKUP</a></strong>(SELF, KEY)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-drop">DROP</a></strong>(SELF, KEY)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-keys">KEYS</a></strong>(MAP)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-has_key">HAS_KEY</a></strong>(MAP, KEY)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-append">APPEND</a></strong>(SELF, ELEM)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-prepend">PREPEND</a></strong>(SELF, ELEM)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-unshift">UNSHIFT</a></strong>(SELF, ELEM)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-prefix">PREFIX</a></strong>(SELF, SLIC)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-head">HEAD</a></strong>(SELF, END)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-tail">TAIL</a></strong>(SELF, BEG)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-first">FIRST</a></strong>(SELF)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-last">LAST</a></strong>(SELF)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-qsort">QSORT</a></strong>(SELF, CMPR) <br>Minimal helper/wrapper around in-place <code>qsort</code> for arrays/slices.</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-sort">SORT</a></strong>(SELF, SUBJ, OTHR, ...)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-cmp">CMP</a></strong>(A, B)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-ansi">ANSI</a></strong>(CODE)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-bold">BOLD</a></strong></td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-faint">FAINT</a></strong></td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-dim">DIM</a></strong></td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-italic">ITALIC</a></strong></td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-under">UNDER</a></strong></td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-blink">BLINK</a></strong></td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-rapid">RAPID</a></strong></td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-invert">INVERT</a></strong></td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-hidden">HIDDEN</a></strong></td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-strike">STRIKE</a></strong></td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-bold_off">BOLD_OFF</a></strong></td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-faint_off">FAINT_OFF</a></strong></td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-italic_off">ITALIC_OFF</a></strong></td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-under_off">UNDER_OFF</a></strong></td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-blink_off">BLINK_OFF</a></strong></td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-rapid_off">RAPID_OFF</a></strong></td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-invert_off">INVERT_OFF</a></strong></td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-hidden_off">HIDDEN_OFF</a></strong></td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-strike_off">STRIKE_OFF</a></strong></td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-reset">RESET</a></strong></td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-min">min</a></strong>(A, B)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-max">max</a></strong>(A, B)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-deref">deref</a></strong>(T, PTR, ALT)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-wrap">WRAP</a></strong>(TYPE, VALUE) <br>Wrap value in wrapper struct.</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-unwrap">UNWRAP</a></strong>(STRUCTURE) <br>Unwraps pointer/value in sizing wrapper struct.</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-ptr">PTR</a></strong>(ARR) <br>Explicitly only extract pointer from array/slice.</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-free_inside">FREE_INSIDE</a></strong>(S) <br>Call to <code>free</code> of inside of slice/array/newtype, etc.</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-init">INIT</a></strong>(TYPE, ...) <br>Initialise sizing wrapper with literal.</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-list">LIST</a></strong>(TYPE, ...) <br>Can be used to make slices from literal arrays.</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-string">STRING</a></strong>(...) <br>Initialise sizing wrapper with of string literal.</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-str">STR</a></strong>(...)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-sempty">SEMPTY</a></strong>(TYPE) <br>Empty slice of certain type.</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-aempty">AEMPTY</a></strong>(TYPE) <br>Empty array of certain type.</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-empty">EMPTY</a></strong>(TYPE) <br>Empty / zero struct.</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-is_empty">IS_EMPTY</a></strong>(ARR) <br>Is array empty?</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-amake">AMAKE</a></strong>(TYPE, CAP) <br>Heap allocates a variable sized array.</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-anew">ANEW</a></strong>(VARIABLE, CAP) <br>Create new array / initialise array from array variable.</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-smake">SMAKE</a></strong>(TYPE, LEN) <br>Heap allocates a constant sized slice type.</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-snew">SNEW</a></strong>(VARIABLE, LEN) <br>Create new slice / initialise slice from slice variable.</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-slice">SLICE</a></strong>(TYPE, OBJ, START, END) <br>Take a slice/substring/view of sized type.</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-view">VIEW</a></strong>(TYPE, PTR, START, END) <br>Works like <code>SLICE</code>, but on a pointer instead of an array.</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-symbolic">SYMBOLIC</a></strong>(STR)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-symbol_literal">SYMBOL_LITERAL</a></strong>(STR_LIT)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-acollect">ACOLLECT</a></strong>(T, count, pointer) <br>C array to dynamic array wrapper.</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-scollect">SCOLLECT</a></strong>(T, count, pointer) <br>C array to slice wrapper.</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-smap">SMAP</a></strong>(T, func, list)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-amap">AMAP</a></strong>(T, func, list)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-for_each">FOR_EACH</a></strong>(ELEM, ELEMS)</td></tr>
<tr><td></td><td><strong><a href="/crelude/Files/common_8h.html#define-foreach">foreach</a></strong></td></tr>
</tbody></table>
</div>
<h2 id="detailed-description"><a class="header" href="#detailed-description">Detailed Description</a></h2>
<p><strong>Note</strong>: Read this: <a href="https://www.cprogramming.com/tutorial/unicode.html">unicode</a> by Jeff Bezanson, about modern unicode in C. </p>
<p>Defines basic macros and datatypes which are in common through-out the whole project. </p>
<h2 id="types-documentation"><a class="header" href="#types-documentation">Types Documentation</a></h2>
<h3 id="enum-hashkeytype"><a class="header" href="#enum-hashkeytype">enum HashKeyType</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Enumerator</th><th>Value</th><th>Description</th></tr></thead><tbody>
<tr><td>HKT_STRING</td><td>1 &lt;&lt; 0</td><td></td></tr>
<tr><td>HKT_RUNIC</td><td>1 &lt;&lt; 1</td><td></td></tr>
<tr><td>HKT_CSTRING</td><td>1 &lt;&lt; 2</td><td></td></tr>
<tr><td>HKT_MEM_SLICE</td><td>1 &lt;&lt; 3</td><td></td></tr>
<tr><td>HKT_RAW_BYTES</td><td>1 &lt;&lt; 4</td><td></td></tr>
<tr><td>HKT_SMALL_INTEGER</td><td>1 &lt;&lt; 5</td><td></td></tr>
</tbody></table>
</div>
<h3 id="typedef-hashkeytype"><a class="header" href="#typedef-hashkeytype">typedef HashKeyType</a></h3>
<pre><code class="language-cpp">typedef enum HashKeyType HashKeyType;
</code></pre>
<h3 id="typedef-atomic_t"><a class="header" href="#typedef-atomic_t">typedef atomic_t</a></h3>
<pre><code class="language-cpp">typedef struct _atomic_t atomic_t;
</code></pre>
<p>Useful for resource counting etc. </p>
<h3 id="typedef-u0"><a class="header" href="#typedef-u0">typedef u0</a></h3>
<pre><code class="language-cpp">typedef void u0;
</code></pre>
<p>The type that occupies no space. Thanks to Terry for this one. </p>
<h3 id="typedef-ierr"><a class="header" href="#typedef-ierr">typedef ierr</a></h3>
<pre><code class="language-cpp">typedef signed int ierr;
</code></pre>
<p>Explicitly mark functions that return error-codes as returning <code>ierr</code> instead of just <code>int</code>. </p>
<h3 id="typedef-uerr"><a class="header" href="#typedef-uerr">typedef uerr</a></h3>
<pre><code class="language-cpp">typedef unsigned int uerr;
</code></pre>
<p>Not something very common. </p>
<h3 id="typedef-uword"><a class="header" href="#typedef-uword">typedef uword</a></h3>
<pre><code class="language-cpp">typedef unsigned long uword;
</code></pre>
<p><code>long</code> is always the same size as a machine word. </p>
<p>Unsigned machine word integer. </p>
<h3 id="typedef-iword"><a class="header" href="#typedef-iword">typedef iword</a></h3>
<pre><code class="language-cpp">typedef signed long iword;
</code></pre>
<p>Signed machine word integer. </p>
<h3 id="typedef-ufast"><a class="header" href="#typedef-ufast">typedef ufast</a></h3>
<pre><code class="language-cpp">typedef unsigned int ufast;
</code></pre>
<p><code>int</code> in most cases is going to have the natural size suggested by the target architecture, optimal for most things. </p>
<h3 id="typedef-ifast"><a class="header" href="#typedef-ifast">typedef ifast</a></h3>
<pre><code class="language-cpp">typedef signed int ifast;
</code></pre>
<h3 id="typedef-isize"><a class="header" href="#typedef-isize">typedef isize</a></h3>
<pre><code class="language-cpp">typedef ptrdiff_t isize;
</code></pre>
<h3 id="typedef-usize"><a class="header" href="#typedef-usize">typedef usize</a></h3>
<pre><code class="language-cpp">typedef size_t usize;
</code></pre>
<p>Use for storing array indices or object sizes. </p>
<h3 id="typedef-iptr"><a class="header" href="#typedef-iptr">typedef iptr</a></h3>
<pre><code class="language-cpp">typedef intptr_t iptr;
</code></pre>
<h3 id="typedef-uptr"><a class="header" href="#typedef-uptr">typedef uptr</a></h3>
<pre><code class="language-cpp">typedef uintptr_t uptr;
</code></pre>
<p>Large enough to store a pointer, like (void *). </p>
<h3 id="typedef-imax"><a class="header" href="#typedef-imax">typedef imax</a></h3>
<pre><code class="language-cpp">typedef intmax_t imax;
</code></pre>
<h3 id="typedef-umax"><a class="header" href="#typedef-umax">typedef umax</a></h3>
<pre><code class="language-cpp">typedef uintmax_t umax;
</code></pre>
<h3 id="typedef-umin"><a class="header" href="#typedef-umin">typedef umin</a></h3>
<pre><code class="language-cpp">typedef unsigned char umin;
</code></pre>
<p>Such that <code>sizeof(umin) == 1</code>. </p>
<h3 id="typedef-imin"><a class="header" href="#typedef-imin">typedef imin</a></h3>
<pre><code class="language-cpp">typedef signed char imin;
</code></pre>
<p>Such that <code>sizeof(imin) == 1</code>. </p>
<h3 id="typedef-i8"><a class="header" href="#typedef-i8">typedef i8</a></h3>
<pre><code class="language-cpp">typedef __int8_t i8;
</code></pre>
<h3 id="typedef-u8"><a class="header" href="#typedef-u8">typedef u8</a></h3>
<pre><code class="language-cpp">typedef __uint8_t u8;
</code></pre>
<h3 id="typedef-byte"><a class="header" href="#typedef-byte">typedef byte</a></h3>
<pre><code class="language-cpp">typedef __uint8_t byte;
</code></pre>
<p>Don't use <code>char</code> when you want <code>byte</code>. </p>
<h3 id="typedef-i16"><a class="header" href="#typedef-i16">typedef i16</a></h3>
<pre><code class="language-cpp">typedef __int16_t i16;
</code></pre>
<h3 id="typedef-u16"><a class="header" href="#typedef-u16">typedef u16</a></h3>
<pre><code class="language-cpp">typedef __uint16_t u16;
</code></pre>
<h3 id="typedef-i32"><a class="header" href="#typedef-i32">typedef i32</a></h3>
<pre><code class="language-cpp">typedef __int32_t i32;
</code></pre>
<h3 id="typedef-u32"><a class="header" href="#typedef-u32">typedef u32</a></h3>
<pre><code class="language-cpp">typedef __uint32_t u32;
</code></pre>
<h3 id="typedef-rune"><a class="header" href="#typedef-rune">typedef rune</a></h3>
<pre><code class="language-cpp">typedef u32 rune;
</code></pre>
<p>Unicode codepoint (USC-4) (32 bits), don't use <code>char[4]</code>, and definitely do not use <code>wchar_t</code>. </p>
<h3 id="typedef-i64"><a class="header" href="#typedef-i64">typedef i64</a></h3>
<pre><code class="language-cpp">typedef __int64_t i64;
</code></pre>
<h3 id="typedef-u64"><a class="header" href="#typedef-u64">typedef u64</a></h3>
<pre><code class="language-cpp">typedef __uint64_t u64;
</code></pre>
<h2 id="functions-documentation"><a class="header" href="#functions-documentation">Functions Documentation</a></h2>
<h3 id="function-_static_assert"><a class="header" href="#function-_static_assert">function _Static_assert</a></h3>
<pre><code class="language-cpp">_Static_assert(
    sizeof(umin)  ==1 &amp;&amp;sizeof(imin)==1,
    &quot;`umin` and `imin` must have size one (1).&quot; 
)
</code></pre>
<h3 id="function-panic"><a class="header" href="#function-panic">function panic</a></h3>
<pre><code class="language-cpp">u0 panic(
    const byte * ,
    ... 
)
</code></pre>
<h3 id="function-or"><a class="header" href="#function-or">function or</a></h3>
<pre><code class="language-cpp">u0 * or(
    const u0 * nullable,
    const u0 * nonnull
)
</code></pre>
<h3 id="function-is_zero"><a class="header" href="#function-is_zero">function is_zero</a></h3>
<pre><code class="language-cpp">bool is_zero(
    imax 
)
</code></pre>
<h3 id="function-is_zerof"><a class="header" href="#function-is_zerof">function is_zerof</a></h3>
<pre><code class="language-cpp">bool is_zerof(
    f64 
)
</code></pre>
<h3 id="function-is_zeroed"><a class="header" href="#function-is_zeroed">function is_zeroed</a></h3>
<pre><code class="language-cpp">bool is_zeroed(
    u0 * ,
    usize 
)
</code></pre>
<h3 id="function-zero"><a class="header" href="#function-zero">function zero</a></h3>
<pre><code class="language-cpp">u0 zero(
    u0 * blk,
    usize width
)
</code></pre>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>blk</strong> Pointer to start of block. </li>
<li><strong>width</strong> How many bytes to zero. e.g., for an array <code>width = lenght * sizeof(elem)</code>. </li>
</ul>
<p>Zero a block of memory. </p>
<h3 id="function-emalloc"><a class="header" href="#function-emalloc">function emalloc</a></h3>
<pre><code class="language-cpp">u0 * emalloc(
    usize ,
    usize 
)
</code></pre>
<p>Malloc with zeros, and panics when out of memory. </p>
<h3 id="function-reverse"><a class="header" href="#function-reverse">function reverse</a></h3>
<pre><code class="language-cpp">u0 reverse(
    u0 * self,
    usize width
)
</code></pre>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>self</strong> A pointer to an array or slice, cast to <code>u0 *</code>. </li>
<li><strong>width</strong> The width/<code>sizeof</code> of an element in the array. </li>
</ul>
<p>Reverse an array or slice in-place. </p>
<h3 id="function-reverse_endianness"><a class="header" href="#function-reverse_endianness">function reverse_endianness</a></h3>
<pre><code class="language-cpp">MemSlice reverse_endianness(
    MemSlice bytes
)
</code></pre>
<p><strong>Note</strong>: Heap allocates, remember to free. </p>
<p>Reverse a slice of bytes. Not in-place. </p>
<h3 id="function-is_little_endian"><a class="header" href="#function-is_little_endian">function is_little_endian</a></h3>
<pre><code class="language-cpp">bool is_little_endian(
    void 
)
</code></pre>
<p><strong>Return</strong>: true if little endian, false if big endian. </p>
<p>Check if system/CPU is using little endian. </p>
<h3 id="function-big_endian"><a class="header" href="#function-big_endian">function big_endian</a></h3>
<pre><code class="language-cpp">u128 big_endian(
    umin * start,
    usize bytes
)
</code></pre>
<p>Read big-endian integer. </p>
<h3 id="function-swap"><a class="header" href="#function-swap">function swap</a></h3>
<pre><code class="language-cpp">u0 swap(
    u0 * self,
    usize pivot,
    usize width
)
</code></pre>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>self</strong> Pointer to the slice, cast to (<code>u0 *</code>). </li>
<li><strong>pivot</strong> The index of the slice that divides the blocks to swap. </li>
<li><strong>width</strong> The <code>sizeof(T)</code> where <code>T</code> is the type of element in the slice. </li>
</ul>
<p>Given a slice, swap the two blocks within the slice formed by selecting a pivot point (in-place). </p>
<pre><code class="language-cpp">[----A----|---B---] -&gt; [---B---|----A----]
          ^ pivot
</code></pre>
<h3 id="function-memswap"><a class="header" href="#function-memswap">function memswap</a></h3>
<pre><code class="language-cpp">u0 memswap(
    umin * a,
    umin * b,
    usize bytes
)
</code></pre>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>a</strong> Block of memory <code>a</code>, to be swapped for <code>b</code>. </li>
<li><strong>b</strong> Block of memory <code>b</code>, to be swapped for <code>a</code>. </li>
<li><strong>bytes</strong> The common size of block <code>a</code> and <code>b</code> in bytes. </li>
</ul>
<p>Swaps two equally sized blocks of memory, overwriting each other. </p>
<h3 id="function-resize"><a class="header" href="#function-resize">function resize</a></h3>
<pre><code class="language-cpp">usize resize(
    u0 * self,
    usize cap,
    usize width
)
</code></pre>
<p><strong>Return</strong>: How much of the array is empty (i.e. <code>cap - len</code>). </p>
<p>Resizes the array, i.e. changes the capacity to a given value. Akin to <code>realloc</code>. </p>
<h3 id="function-grow"><a class="header" href="#function-grow">function grow</a></h3>
<pre><code class="language-cpp">usize grow(
    u0 * self,
    usize count,
    usize width
)
</code></pre>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>self</strong> Void-pointer to array structure. </li>
<li><strong>count</strong> Number of spaces to grow by. </li>
<li><strong>width</strong> Size of the individual elements in the array, in bytes. </li>
</ul>
<p><strong>Return</strong>: How much capacity increased. </p>
<p>Grows the array length by <code>count</code>, reallocates if necessary. Does nothing else. </p>
<h3 id="function-get"><a class="header" href="#function-get">function get</a></h3>
<pre><code class="language-cpp">u0 * get(
    u0 * self,
    usize index,
    usize width
)
</code></pre>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>self</strong> Pointer to slice or array. </li>
<li><strong>index</strong> Index of element you wish to retrieve. </li>
<li><strong>width</strong> Size of single array element in bytes. </li>
</ul>
<p><strong>Return</strong>: Pointer to element, or NULL if not present / out of bounds. </p>
<p>Get pointer to element at index in slice/array. </p>
<h3 id="function-set"><a class="header" href="#function-set">function set</a></h3>
<pre><code class="language-cpp">u0 * set(
    u0 * self,
    usize index,
    const u0 * elem,
    usize width
)
</code></pre>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>self</strong> Pointer to slice or array. </li>
<li><strong>index</strong> Index of element you wish to set. </li>
<li><strong>width</strong> Size of single array element in bytes. </li>
</ul>
<p><strong>Return</strong>: Pointer to element just set, or NULL if out of bounds. </p>
<p>Set element at index in slice/array. </p>
<h3 id="function-push"><a class="header" href="#function-push">function push</a></h3>
<pre><code class="language-cpp">usize push(
    u0 * self,
    const u0 * element,
    usize width
)
</code></pre>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>self</strong> Pointer to the dynamic array, cast to (<code>u0 *</code>). </li>
<li><strong>element</strong> Pointer to element to be pushed, cast to (<code>u0 *</code>). </li>
<li><strong>width</strong> The <code>sizeof(T)</code> where <code>T</code> is the type of the element that is being pushed. </li>
</ul>
<p><strong>Return</strong>: How much capacity increased. </p>
<p>Push element to array. </p>
<h3 id="function-pop"><a class="header" href="#function-pop">function pop</a></h3>
<pre><code class="language-cpp">u0 * pop(
    u0 * self,
    usize width
)
</code></pre>
<p><strong>Return</strong>: Pointer to popped element. </p>
<p>Pops/removes element from top of the stack (dynamic array). </p>
<h3 id="function-shift"><a class="header" href="#function-shift">function shift</a></h3>
<pre><code class="language-cpp">u0 * shift(
    u0 * self,
    usize width
)
</code></pre>
<p>Works like <code>pop</code> but removes from the front. </p>
<h3 id="function-insert"><a class="header" href="#function-insert">function insert</a></h3>
<pre><code class="language-cpp">usize insert(
    u0 * self,
    usize index,
    const u0 * element,
    usize width
)
</code></pre>
<p><strong>Return</strong>: How much capacity increased. </p>
<p>Exactly like <code>push</code>, except position of element is arbitrary, with index specified in second argument. </p>
<h3 id="function-extend"><a class="header" href="#function-extend">function extend</a></h3>
<pre><code class="language-cpp">usize extend(
    u0 * self,
    const u0 * slice,
    usize width
)
</code></pre>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>self</strong> A pointer to a dynamic array, of any type. </li>
<li><strong>slice</strong> A pointer to a slice, and a slice only (<em>not</em> an array, dynamic array, etc.). </li>
<li><strong>width</strong> The <code>sizeof(T)</code> where <code>T</code> is the type of the individual elements that are being appended to the array. </li>
</ul>
<p><strong>Return</strong>: How much capacity increased. </p>
<p>Works like push, but extends the array by multiple elements. </p>
<h3 id="function-splice"><a class="header" href="#function-splice">function splice</a></h3>
<pre><code class="language-cpp">usize splice(
    u0 * self,
    usize index,
    const u0 * slice,
    usize width
)
</code></pre>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>self</strong> A pointer to the dynamic array, of any type. </li>
<li><strong>index</strong> The location for inserting in the slice. </li>
<li><strong>slice</strong> The slice you wish to insert at <code>index</code>. </li>
<li><strong>width</strong> The <code>sizeof(T)</code> where <code>T</code> is the type of the individual elements stored within the array and slice. </li>
</ul>
<p><strong>Return</strong>: How much capacity increased. </p>
<p>Works like extend, but extends or <em>splices</em> the array with a slice at some given, arbitrary position. </p>
<h3 id="function-cut"><a class="header" href="#function-cut">function cut</a></h3>
<pre><code class="language-cpp">GenericSlice cut(
    u0 * self,
    usize from,
    isize upto,
    usize width
)
</code></pre>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>self</strong> A pointer to the array. </li>
<li><strong>from</strong> Index to start removing from. </li>
<li><strong>upto</strong> Index of final element to remove in the range. If parameter is negative, it indicates an index from the end of the array. </li>
</ul>
<p><strong>Return</strong>: A slice holding a void-pointer to the removed elements, </p>
<p>Deletes a range of elements from an array, starting from some index. </p>
<h3 id="function-null"><a class="header" href="#function-null">function null</a></h3>
<pre><code class="language-cpp">usize null(
    u0 * self,
    usize width
)
</code></pre>
<p><strong>Return</strong>: Number of bytes nulled. </p>
<p>Zero out an array. </p>
<h3 id="function-from_cstring"><a class="header" href="#function-from_cstring">function from_cstring</a></h3>
<pre><code class="language-cpp">string from_cstring(
    const byte * 
)
</code></pre>
<p>NUL-terminated string to library string. </p>
<h3 id="function-string_eq"><a class="header" href="#function-string_eq">function string_eq</a></h3>
<pre><code class="language-cpp">bool string_eq(
    const string,
    const string
)
</code></pre>
<p>Compare two strings for equality. </p>
<h3 id="function-string_cmp"><a class="header" href="#function-string_cmp">function string_cmp</a></h3>
<pre><code class="language-cpp">i16 string_cmp(
    const string,
    const string
)
</code></pre>
<p>Compare two strings for alphabetic rank. </p>
<h3 id="function-string_ncmp"><a class="header" href="#function-string_ncmp">function string_ncmp</a></h3>
<pre><code class="language-cpp">i16 string_ncmp(
    const string,
    const string,
    usize n
)
</code></pre>
<p>Compare two strings for alphabetic rank upto a given number of bytes. </p>
<h3 id="function-hash_string"><a class="header" href="#function-hash_string">function hash_string</a></h3>
<pre><code class="language-cpp">u64 hash_string(
    const string
)
</code></pre>
<p>Hash a string. </p>
<h3 id="function-hash_bytes"><a class="header" href="#function-hash_bytes">function hash_bytes</a></h3>
<pre><code class="language-cpp">u64 hash_bytes(
    const MemSlice
)
</code></pre>
<p>Hash a byte slice. </p>
<h3 id="function-associate"><a class="header" href="#function-associate">function associate</a></h3>
<pre><code class="language-cpp">u0 associate(
    u0 * self,
    const u0 * key,
    const u0 * value
)
</code></pre>
<p>Map / associate a key with a value, i.e. insert into the hash-map/table. </p>
<h3 id="function-lookup"><a class="header" href="#function-lookup">function lookup</a></h3>
<pre><code class="language-cpp">u0 * lookup(
    u0 * self,
    const u0 * key
)
</code></pre>
<p>Look-up / get value from hash-map/table given the key. </p>
<h3 id="function-drop"><a class="header" href="#function-drop">function drop</a></h3>
<pre><code class="language-cpp">bool drop(
    u0 * self,
    const u0 * key
)
</code></pre>
<p><strong>Return</strong>: <code>true</code> if key was present, and node was deleted, <code>false</code> if not. </p>
<p>Drop / delete / remove key-value pair from the hash-table. This frees/deallocates the node, and the key and value are deleted. Does nothing if key did not exist in the table. </p>
<h3 id="function-get_keys"><a class="header" href="#function-get_keys">function get_keys</a></h3>
<pre><code class="language-cpp">GenericSlice get_keys(
    u0 * self
)
</code></pre>
<p><strong>Note</strong>: Returns a heap allocated slice, remember to free. </p>
<p>Get slice of key pointers of all keys in map/hash-table. </p>
<h3 id="function-has_key"><a class="header" href="#function-has_key">function has_key</a></h3>
<pre><code class="language-cpp">bool has_key(
    u0 * self,
    u0 * key
)
</code></pre>
<p>Checks if entry / key-value pair is present in hash-table/map given a key. </p>
<h3 id="function-empty_map"><a class="header" href="#function-empty_map">function empty_map</a></h3>
<pre><code class="language-cpp">u0 empty_map(
    u0 * self
)
</code></pre>
<p>Empties out / deallocates all key-value pairs from the map. Map may still be repopulated again after this. </p>
<h3 id="function-is_empty_map"><a class="header" href="#function-is_empty_map">function is_empty_map</a></h3>
<pre><code class="language-cpp">bool is_empty_map(
    u0 * self
)
</code></pre>
<p>Checks if the hash-table / map is empty or freed. </p>
<h3 id="function-free_map"><a class="header" href="#function-free_map">function free_map</a></h3>
<pre><code class="language-cpp">u0 free_map(
    u0 * self
)
</code></pre>
<p>Frees the map. Not only empties it, but deallocates bucket array such that the map may not be used again. </p>
<h3 id="function-init_hashnode"><a class="header" href="#function-init_hashnode">function init_hashnode</a></h3>
<pre><code class="language-cpp">usize init_hashnode(
    u0 * ,
    const u0 * ,
    u64 ,
    const u0 * ,
    const u0 * 
)
</code></pre>
<p>Internal use 99% of the time. </p>
<h3 id="function-dump_hashmap"><a class="header" href="#function-dump_hashmap">function dump_hashmap</a></h3>
<pre><code class="language-cpp">u0 dump_hashmap(
    u0 * self,
    byte * key_formatter,
    byte * value_formatter
)
</code></pre>
<p>Hashmap debugging function. </p>
<h3 id="function-attribute"><a class="header" href="#function-attribute">function <strong>attribute</strong></a></h3>
<pre><code class="language-cpp">__attribute__(
    (unused) 
) const
</code></pre>
<h3 id="function-hash_bytes-1"><a class="header" href="#function-hash_bytes-1">function hash_bytes</a></h3>
<pre><code class="language-cpp">return hash_bytes(
    __extension__({ __auto_type _self=(runes);MemSlice _bytes={ .len=_self.len *sizeof(*_self.value),.value=(umin *) _self.value };_bytes;}) 
)
</code></pre>
<h3 id="function-hash_string-1"><a class="header" href="#function-hash_string-1">function hash_string</a></h3>
<pre><code class="language-cpp">return hash_string(
    from_cstring(*(byte **) key) 
)
</code></pre>
<h2 id="attributes-documentation"><a class="header" href="#attributes-documentation">Attributes Documentation</a></h2>
<h3 id="variable-hash"><a class="header" href="#variable-hash">variable hash</a></h3>
<pre><code class="language-cpp">u64 hash;
</code></pre>
<h3 id="variable-value"><a class="header" href="#variable-value">variable value</a></h3>
<pre><code class="language-cpp">u0 * value;
</code></pre>
<h3 id="variable-key"><a class="header" href="#variable-key">variable key</a></h3>
<pre><code class="language-cpp">struct @21 key;
</code></pre>
<h3 id="variable-next"><a class="header" href="#variable-next">variable next</a></h3>
<pre><code class="language-cpp">u0 * next;
</code></pre>
<h3 id="variable-nul"><a class="header" href="#variable-nul">variable NUL</a></h3>
<pre><code class="language-cpp">static const ierr NUL = 0;
</code></pre>
<h3 id="variable-nul_byte"><a class="header" href="#variable-nul_byte">variable NUL_BYTE</a></h3>
<pre><code class="language-cpp">static const byte NUL_BYTE = '\0';
</code></pre>
<h3 id="variable-nul_string"><a class="header" href="#variable-nul_string">variable NUL_STRING</a></h3>
<pre><code class="language-cpp">static const string NUL_STRING = { .[len](/crelude/Files/base64_8h.md#variable-len) = 0, .[value](/crelude/Files/common_8h.md#variable-value) = ([byte](/crelude/Files/common_8h.md#typedef-byte) *)&amp;[NUL_BYTE](/crelude/Files/common_8h.md#variable-nul_byte) };
</code></pre>
<h3 id="variable-zero"><a class="header" href="#variable-zero">variable ZERO</a></h3>
<pre><code class="language-cpp">static const iword ZERO = 0;
</code></pre>
<h3 id="variable-_"><a class="header" href="#variable-_">variable _</a></h3>
<pre><code class="language-cpp">usize _ {
	[UNUSED1](/crelude/Files/common_8h.md#define-unused1);
</code></pre>
<h3 id="variable-runes"><a class="header" href="#variable-runes">variable runes</a></h3>
<pre><code class="language-cpp">runic runes = *([runic](/crelude/Classes/structrunic.md) *)[key](/crelude/Files/common_8h.md#variable-key);
</code></pre>
<h3 id="variable-size"><a class="header" href="#variable-size">variable size</a></h3>
<pre><code class="language-cpp">usize size {
	[u64](/crelude/Files/common_8h.md#typedef-u64)[hash](/crelude/Files/common_8h.md#variable-hash) = 0;
</code></pre>
<h2 id="macros-documentation"><a class="header" href="#macros-documentation">Macros Documentation</a></h2>
<h3 id="define-_gnu_source"><a class="header" href="#define-_gnu_source">define _GNU_SOURCE</a></h3>
<pre><code class="language-cpp">#define _GNU_SOURCE 1
</code></pre>
<p>Use GNU specific source. </p>
<h3 id="define-free"><a class="header" href="#define-free">define FREE</a></h3>
<pre><code class="language-cpp">#define FREE free
</code></pre>
<h3 id="define-malloc"><a class="header" href="#define-malloc">define MALLOC</a></h3>
<pre><code class="language-cpp">#define MALLOC malloc
</code></pre>
<h3 id="define-realloc"><a class="header" href="#define-realloc">define REALLOC</a></h3>
<pre><code class="language-cpp">#define REALLOC realloc
</code></pre>
<h3 id="define-va_num_args_impl"><a class="header" href="#define-va_num_args_impl">define VA_NUM_ARGS_IMPL</a></h3>
<pre><code class="language-cpp">#define VA_NUM_ARGS_IMPL(
    _1,
    _2,
    _3,
    _4,
    _5,
    N,
    ...
)
N
</code></pre>
<h3 id="define-va_num_args"><a class="header" href="#define-va_num_args">define VA_NUM_ARGS</a></h3>
<pre><code class="language-cpp">#define VA_NUM_ARGS(
    ...
)
[VA_NUM_ARGS_IMPL](/crelude/Files/common_8h.md#define-va_num_args_impl)(__VA_ARGS__, 5, 4, 3, 2, 1)
</code></pre>
<h3 id="define-_tstr"><a class="header" href="#define-_tstr">define _TSTR</a></h3>
<pre><code class="language-cpp">#define _TSTR(
    x
)
#x
</code></pre>
<h3 id="define-tstr"><a class="header" href="#define-tstr">define TSTR</a></h3>
<pre><code class="language-cpp">#define TSTR(
    x
)
[_TSTR](/crelude/Files/common_8h.md#define-_tstr)(x)
</code></pre>
<h3 id="define-todo"><a class="header" href="#define-todo">define TODO</a></h3>
<pre><code class="language-cpp">#define TODO(
    ...
)
                            DO_PRAGMA(message(&quot;TODO: &quot; #__VA_ARGS__ \
                            &quot; (&quot; __FILE__ &quot;:&quot; [TSTR](/crelude/Files/common_8h.md#define-tstr)(__LINE__)&quot;)&quot;))
</code></pre>
<h3 id="define-crelude_v_major"><a class="header" href="#define-crelude_v_major">define crelude_V_MAJOR</a></h3>
<pre><code class="language-cpp">#define crelude_V_MAJOR 0
</code></pre>
<h3 id="define-crelude_v_minor"><a class="header" href="#define-crelude_v_minor">define crelude_V_MINOR</a></h3>
<pre><code class="language-cpp">#define crelude_V_MINOR 1
</code></pre>
<h3 id="define-crelude_v_patch"><a class="header" href="#define-crelude_v_patch">define crelude_V_PATCH</a></h3>
<pre><code class="language-cpp">#define crelude_V_PATCH 0
</code></pre>
<h3 id="define-crelude_version"><a class="header" href="#define-crelude_version">define crelude_VERSION</a></h3>
<pre><code class="language-cpp">#define crelude_VERSION 	&quot;v&quot; TSTR([crelude_V_MAJOR](/crelude/Files/common_8h.md#define-crelude_v_major)) \
	&quot;.&quot; [TSTR](/crelude/Files/common_8h.md#define-tstr)([crelude_V_MINOR](/crelude/Files/common_8h.md#define-crelude_v_minor)) \
	&quot;.&quot; [TSTR](/crelude/Files/common_8h.md#define-tstr)([crelude_V_PATCH](/crelude/Files/common_8h.md#define-crelude_v_patch))
</code></pre>
<h3 id="define-array_realloc_factor"><a class="header" href="#define-array_realloc_factor">define ARRAY_REALLOC_FACTOR</a></h3>
<pre><code class="language-cpp">#define ARRAY_REALLOC_FACTOR 1.5
</code></pre>
<h3 id="define-loop"><a class="header" href="#define-loop">define loop</a></h3>
<pre><code class="language-cpp">#define loop while (1)
</code></pre>
<h3 id="define-whilst"><a class="header" href="#define-whilst">define whilst</a></h3>
<pre><code class="language-cpp">#define whilst while
</code></pre>
<h3 id="define-unless"><a class="header" href="#define-unless">define unless</a></h3>
<pre><code class="language-cpp">#define unless(
    cond
)
if (!(cond))
</code></pre>
<h3 id="define-never"><a class="header" href="#define-never">define never</a></h3>
<pre><code class="language-cpp">#define never if (0)
</code></pre>
<h3 id="define-always"><a class="header" href="#define-always">define always</a></h3>
<pre><code class="language-cpp">#define always if (1)
</code></pre>
<h3 id="define-until"><a class="header" href="#define-until">define until</a></h3>
<pre><code class="language-cpp">#define until(
    cond
)
while (!(cond))
</code></pre>
<h3 id="define-unqualify"><a class="header" href="#define-unqualify">define unqualify</a></h3>
<pre><code class="language-cpp">#define unqualify(
    D,
    T
)
typedef D T T
</code></pre>
<h3 id="define-record"><a class="header" href="#define-record">define record</a></h3>
<pre><code class="language-cpp">#define record(
    NAME
)
typedef struct [_](/crelude/Files/common_8h.md#variable-_)##NAME NAME; struct [_](/crelude/Files/common_8h.md#variable-_)##NAME
</code></pre>
<h3 id="define-enumerable"><a class="header" href="#define-enumerable">define enumerable</a></h3>
<pre><code class="language-cpp">#define enumerable(
    NAME
)
typedef   enum [_](/crelude/Files/common_8h.md#variable-_)##NAME NAME;   enum [_](/crelude/Files/common_8h.md#variable-_)##NAME
</code></pre>
<h3 id="define-overlap"><a class="header" href="#define-overlap">define overlap</a></h3>
<pre><code class="language-cpp">#define overlap(
    NAME
)
typedef  union [_](/crelude/Files/common_8h.md#variable-_)##NAME NAME;  union [_](/crelude/Files/common_8h.md#variable-_)##NAME
</code></pre>
<h3 id="define-newtype"><a class="header" href="#define-newtype">define newtype</a></h3>
<pre><code class="language-cpp">#define newtype(
    NT,
    T
)
typedef struct [_](/crelude/Files/common_8h.md#variable-_)##NT { T [value](/crelude/Files/common_8h.md#variable-value); } NT
</code></pre>
<h3 id="define-arrayof"><a class="header" href="#define-arrayof">define arrayof</a></h3>
<pre><code class="language-cpp">#define arrayof(
    T
)
	struct { \
	T (*[value](/crelude/Files/common_8h.md#variable-value)); \
	[usize](/crelude/Files/common_8h.md#typedef-usize)[len](/crelude/Files/base64_8h.md#variable-len);  \
	[usize](/crelude/Files/common_8h.md#typedef-usize) cap;  \
}
</code></pre>
<h3 id="define-newarray"><a class="header" href="#define-newarray">define newarray</a></h3>
<pre><code class="language-cpp">#define newarray(
    NT,
    T
)
typedef [arrayof](/crelude/Files/common_8h.md#define-arrayof)(T) NT
</code></pre>
<h3 id="define-sliceof"><a class="header" href="#define-sliceof">define sliceof</a></h3>
<pre><code class="language-cpp">#define sliceof(
    T
)
	struct { \
	T (*[value](/crelude/Files/common_8h.md#variable-value)); \
	[usize](/crelude/Files/common_8h.md#typedef-usize)[len](/crelude/Files/base64_8h.md#variable-len);  \
}
</code></pre>
<h3 id="define-newslice"><a class="header" href="#define-newslice">define newslice</a></h3>
<pre><code class="language-cpp">#define newslice(
    NT,
    T
)
typedef [sliceof](/crelude/Files/common_8h.md#define-sliceof)(T) NT
</code></pre>
<h3 id="define-hashof"><a class="header" href="#define-hashof">define hashof</a></h3>
<pre><code class="language-cpp">#define hashof(
    T
)
	struct { \
	[u64](/crelude/Files/common_8h.md#typedef-u64)[hash](/crelude/Files/common_8h.md#variable-hash); \
	T [value](/crelude/Files/common_8h.md#variable-value);  \
}
</code></pre>
<h3 id="define-newhashable"><a class="header" href="#define-newhashable">define newhashable</a></h3>
<pre><code class="language-cpp">#define newhashable(
    NT,
    T
)
typedef [hashof](/crelude/Files/common_8h.md#define-hashof)(T) NT
</code></pre>
<h3 id="define-hashmap_load_threshold"><a class="header" href="#define-hashmap_load_threshold">define HASHMAP_LOAD_THRESHOLD</a></h3>
<pre><code class="language-cpp">#define HASHMAP_LOAD_THRESHOLD 0.85
</code></pre>
<h3 id="define-hashmap_growth_factor"><a class="header" href="#define-hashmap_growth_factor">define HASHMAP_GROWTH_FACTOR</a></h3>
<pre><code class="language-cpp">#define HASHMAP_GROWTH_FACTOR 2
</code></pre>
<h3 id="define-newmap"><a class="header" href="#define-newmap">define newmap</a></h3>
<pre><code class="language-cpp">#define newmap(
    NT,
    K,
    V
)
typedef [mapof](/crelude/Files/common_8h.md#define-mapof)(K, V) NT
</code></pre>
<h3 id="define-mapof"><a class="header" href="#define-mapof">define mapof</a></h3>
<pre><code class="language-cpp">#define mapof(
    K,
    V
)
	struct { \
	[usize](/crelude/Files/common_8h.md#typedef-usize)[len](/crelude/Files/base64_8h.md#variable-len); \
	[arrayof](/crelude/Files/common_8h.md#define-arrayof)([hashnode](/crelude/Files/common_8h.md#define-hashnode)(K, V)) buckets; /* a [hash](/crelude/Files/common_8h.md#variable-hash)[value](/crelude/Files/common_8h.md#variable-value) of [zero](/crelude/Files/common_8h.md#function-zero) indicates absence. */\
	[usize](/crelude/Files/common_8h.md#typedef-usize) value_size; \
	[usize](/crelude/Files/common_8h.md#typedef-usize)   key_size; \
	[usize](/crelude/Files/common_8h.md#typedef-usize)  node_size; \
	/* offsets of `[hashnode](/crelude/Files/common_8h.md#define-hashnode)` struct. */ \
	[usize](/crelude/Files/common_8h.md#typedef-usize)  hash_offset; \
	[usize](/crelude/Files/common_8h.md#typedef-usize)   key_offset; \
	[usize](/crelude/Files/common_8h.md#typedef-usize) value_offset; \
	[usize](/crelude/Files/common_8h.md#typedef-usize)  next_offset; \
	[HashKeyType](/crelude/Files/common_8h.md#enum-hashkeytype) key_type; /* &lt; how should the [hash](/crelude/Files/common_8h.md#variable-hash)-function [hash](/crelude/Files/common_8h.md#variable-hash) the key. */ \
	[u64](/crelude/Files/common_8h.md#typedef-u64) (*hasher)(const [u0](/crelude/Files/common_8h.md#typedef-u0) *, [usize](/crelude/Files/common_8h.md#typedef-usize)); \
}
</code></pre>
<h3 id="define-hashnode"><a class="header" href="#define-hashnode">define hashnode</a></h3>
<pre><code class="language-cpp">#define hashnode(
    K,
    V
)
	struct { \
	[hashof](/crelude/Files/common_8h.md#define-hashof)(K) [key](/crelude/Files/common_8h.md#variable-key); \
	V [value](/crelude/Files/common_8h.md#variable-value);  /* &lt; [value](/crelude/Files/common_8h.md#variable-value) stored.   */ \
	[u0](/crelude/Files/common_8h.md#typedef-u0) *[next](/crelude/Files/common_8h.md#variable-next); /* &lt; [next](/crelude/Files/common_8h.md#variable-next)[hash](/crelude/Files/common_8h.md#variable-hash)-node. */ \
}
</code></pre>
<h3 id="define-mmake"><a class="header" href="#define-mmake">define MMAKE</a></h3>
<pre><code class="language-cpp">#define MMAKE(
    K,
    V,
    CAP
)

</code></pre>
<h3 id="define-mnew"><a class="header" href="#define-mnew">define MNEW</a></h3>
<pre><code class="language-cpp">#define MNEW(
    VARIABLE,
    CAP
)
	(typeof(VARIABLE))[MMAKE](/crelude/Files/common_8h.md#define-mmake)( \
	typeof((VARIABLE).[buckets.value](/crelude/Files/common_8h.md#variable-value)[0].[key.value](/crelude/Files/common_8h.md#variable-value)), \
	typeof((VARIABLE).[buckets.value](/crelude/Files/common_8h.md#variable-value)[0].[value](/crelude/Files/common_8h.md#variable-value)), \
	CAP)
</code></pre>
<p>Create new map / initialise map from map variable. </p>
<h3 id="define-nth"><a class="header" href="#define-nth">define NTH</a></h3>
<pre><code class="language-cpp">#define NTH(
    LIST,
    N
)
[UNWRAP](/crelude/Files/common_8h.md#define-unwrap)(([LIST](/crelude/Files/common_8h.md#define-list)))[(N)]
</code></pre>
<h3 id="define-get"><a class="header" href="#define-get">define GET</a></h3>
<pre><code class="language-cpp">#define GET(
    LIST,
    N
)
	__extension__\
	({ __auto_type _list = ([LIST](/crelude/Files/common_8h.md#define-list)); \
	   __auto_type _n = (N); \
	   [usize](/crelude/Files/common_8h.md#typedef-usize) _index = _n &lt; 0 ? ([usize](/crelude/Files/common_8h.md#typedef-usize))([_list.len](/crelude/Files/base64_8h.md#variable-len) + _n) : ([usize](/crelude/Files/common_8h.md#typedef-usize))_n; \
	   [UNWRAP](/crelude/Files/common_8h.md#define-unwrap)(_list)[_index]; })
</code></pre>
<h3 id="define-set"><a class="header" href="#define-set">define SET</a></h3>
<pre><code class="language-cpp">#define SET(
    LIST,
    N,
    V
)
	__extension__\
	({ __auto_type _list = ([LIST](/crelude/Files/common_8h.md#define-list)); \
	   __auto_type _n = (N); \
	   [usize](/crelude/Files/common_8h.md#typedef-usize) _index = _n &lt; 0 ? ([usize](/crelude/Files/common_8h.md#typedef-usize))([_list.len](/crelude/Files/base64_8h.md#variable-len) + _n) : ([usize](/crelude/Files/common_8h.md#typedef-usize))_n; \
	   [UNWRAP](/crelude/Files/common_8h.md#define-unwrap)(_list)[_index] = (V); })
</code></pre>
<h3 id="define-unused1"><a class="header" href="#define-unused1">define UNUSED1</a></h3>
<pre><code class="language-cpp">#define UNUSED1(
    z
)
(void)(z)
</code></pre>
<h3 id="define-unused2"><a class="header" href="#define-unused2">define UNUSED2</a></h3>
<pre><code class="language-cpp">#define UNUSED2(
    y,
    z
)
[UNUSED1](/crelude/Files/common_8h.md#define-unused1)(y),[UNUSED1](/crelude/Files/common_8h.md#define-unused1)(z)
</code></pre>
<h3 id="define-unused3"><a class="header" href="#define-unused3">define UNUSED3</a></h3>
<pre><code class="language-cpp">#define UNUSED3(
    x,
    y,
    z
)
[UNUSED1](/crelude/Files/common_8h.md#define-unused1)(x),[UNUSED2](/crelude/Files/common_8h.md#define-unused2)(y,z)
</code></pre>
<h3 id="define-unused4"><a class="header" href="#define-unused4">define UNUSED4</a></h3>
<pre><code class="language-cpp">#define UNUSED4(
    b,
    x,
    y,
    z
)
[UNUSED2](/crelude/Files/common_8h.md#define-unused2)(b,x),[UNUSED2](/crelude/Files/common_8h.md#define-unused2)(y,z)
</code></pre>
<h3 id="define-unused5"><a class="header" href="#define-unused5">define UNUSED5</a></h3>
<pre><code class="language-cpp">#define UNUSED5(
    a,
    b,
    x,
    y,
    z
)
[UNUSED2](/crelude/Files/common_8h.md#define-unused2)(a,b),[UNUSED3](/crelude/Files/common_8h.md#define-unused3)(x,y,z)
</code></pre>
<h3 id="define-unused_impl_"><a class="header" href="#define-unused_impl_">define UNUSED_IMPL_</a></h3>
<pre><code class="language-cpp">#define UNUSED_IMPL_(
    nargs
)
[UNUSED](/crelude/Files/common_8h.md#define-unused) ## nargs
</code></pre>
<h3 id="define-unused_impl"><a class="header" href="#define-unused_impl">define UNUSED_IMPL</a></h3>
<pre><code class="language-cpp">#define UNUSED_IMPL(
    nargs
)
[UNUSED_IMPL_](/crelude/Files/common_8h.md#define-unused_impl_)(nargs)
</code></pre>
<h3 id="define-unused"><a class="header" href="#define-unused">define UNUSED</a></h3>
<pre><code class="language-cpp">#define UNUSED(
    ...
)
[UNUSED_IMPL](/crelude/Files/common_8h.md#define-unused_impl)([VA_NUM_ARGS](/crelude/Files/common_8h.md#define-va_num_args)(__VA_ARGS__))(__VA_ARGS__)
</code></pre>
<h3 id="define-no_error"><a class="header" href="#define-no_error">define NO_ERROR</a></h3>
<pre><code class="language-cpp">#define NO_ERROR EXIT_SUCCESS
</code></pre>
<h3 id="define-ok"><a class="header" href="#define-ok">define OK</a></h3>
<pre><code class="language-cpp">#define OK EXIT_SUCCESS
</code></pre>
<h3 id="define-okay"><a class="header" href="#define-okay">define OKAY</a></h3>
<pre><code class="language-cpp">#define OKAY EXIT_SUCCESS
</code></pre>
<h3 id="define-fail"><a class="header" href="#define-fail">define FAIL</a></h3>
<pre><code class="language-cpp">#define FAIL EXIT_FAILURE
</code></pre>
<h3 id="define-noop"><a class="header" href="#define-noop">define NOOP</a></h3>
<pre><code class="language-cpp">#define NOOP ((void)0)
</code></pre>
<h3 id="define-nil"><a class="header" href="#define-nil">define nil</a></h3>
<pre><code class="language-cpp">#define nil ((void *)NULL)
</code></pre>
<h3 id="define-floor"><a class="header" href="#define-floor">define FLOOR</a></h3>
<pre><code class="language-cpp">#define FLOOR(
    T,
    N
)
	__extension__\
	({ typeof(N) _n = (N); \
	   (T)_n - (_n &lt; 0 ? 1 : 0); })
</code></pre>
<h3 id="define-ceil"><a class="header" href="#define-ceil">define CEIL</a></h3>
<pre><code class="language-cpp">#define CEIL(
    T,
    N
)
	__extension__\
	({ typeof(N) _n = (N); \
	   (T)_n + (_n &lt; 0 ? 0 : 1); })
</code></pre>
<h3 id="define-unit"><a class="header" href="#define-unit">define UNIT</a></h3>
<pre><code class="language-cpp">#define UNIT ;
</code></pre>
<h3 id="define-word_size"><a class="header" href="#define-word_size">define WORD_SIZE</a></h3>
<pre><code class="language-cpp">#define WORD_SIZE sizeof(long)
</code></pre>
<p>Size of a machine word in bytes. </p>
<h3 id="define-uchar8"><a class="header" href="#define-uchar8">define <strong>UCHAR8</strong></a></h3>
<pre><code class="language-cpp">#define __UCHAR8__ char
</code></pre>
<h3 id="define-uchar8-1"><a class="header" href="#define-uchar8-1">define <strong>UCHAR8</strong></a></h3>
<pre><code class="language-cpp">#define __UCHAR8__ char
</code></pre>
<h3 id="define-_float_bit"><a class="header" href="#define-_float_bit">define _FLOAT_BIT</a></h3>
<pre><code class="language-cpp">#define _FLOAT_BIT (__SIZEOF_FLOAT__       * CHAR_BIT)
</code></pre>
<h3 id="define-_double_bit"><a class="header" href="#define-_double_bit">define _DOUBLE_BIT</a></h3>
<pre><code class="language-cpp">#define _DOUBLE_BIT (__SIZEOF_DOUBLE__      * CHAR_BIT)
</code></pre>
<h3 id="define-_ldouble_bit"><a class="header" href="#define-_ldouble_bit">define _LDOUBLE_BIT</a></h3>
<pre><code class="language-cpp">#define _LDOUBLE_BIT (__SIZEOF_LONG_DOUBLE__ * CHAR_BIT)
</code></pre>
<h3 id="define-copy"><a class="header" href="#define-copy">define COPY</a></h3>
<pre><code class="language-cpp">#define COPY(
    SELF
)
	__extension__\
	({ __auto_type _self = (SELF); \
	   __auto_type _copy = _self; \
	   [PTR](/crelude/Files/common_8h.md#define-ptr)(_copy) = [emalloc](/crelude/Files/common_8h.md#function-emalloc)([_self.len](/crelude/Files/base64_8h.md#variable-len), sizeof(*[PTR](/crelude/Files/common_8h.md#define-ptr)(_self))); \
	   memcpy([PTR](/crelude/Files/common_8h.md#define-ptr)(_copy), [PTR](/crelude/Files/common_8h.md#define-ptr)(_self), sizeof(*[PTR](/crelude/Files/common_8h.md#define-ptr)(_copy)) * [_copy.len](/crelude/Files/base64_8h.md#variable-len)); \
	   _copy; })
</code></pre>
<p><strong>Note</strong>: Allocates on the heap. </p>
<p>Copy an array or slice. </p>
<h3 id="define-to_bytes"><a class="header" href="#define-to_bytes">define TO_BYTES</a></h3>
<pre><code class="language-cpp">#define TO_BYTES(
    SELF
)
	__extension__\
	({ __auto_type _self = (SELF); \
	   [MemSlice](/crelude/Classes/structMemSlice.md) _bytes = { \
		  .[len](/crelude/Files/base64_8h.md#variable-len) = [_self.len](/crelude/Files/base64_8h.md#variable-len) * sizeof(*[_self.value](/crelude/Files/common_8h.md#variable-value)), \
		  .[value](/crelude/Files/common_8h.md#variable-value) = ([umin](/crelude/Files/common_8h.md#typedef-umin) *)[_self.value](/crelude/Files/common_8h.md#variable-value) \
	   }; _bytes; })
</code></pre>
<p>Convert array/slice to slice of bytes. </p>
<h3 id="define-from_bytes"><a class="header" href="#define-from_bytes">define FROM_BYTES</a></h3>
<pre><code class="language-cpp">#define FROM_BYTES(
    T,
    SELF
)
	__extension__\
	({ __auto_type _self = (SELF); \
	   T _normal = { \
		  .[len](/crelude/Files/base64_8h.md#variable-len) = [_self.len](/crelude/Files/base64_8h.md#variable-len) / sizeof(*[_self.value](/crelude/Files/common_8h.md#variable-value)), \
		  .[value](/crelude/Files/common_8h.md#variable-value) = ([u0](/crelude/Files/common_8h.md#typedef-u0) *)[_self.value](/crelude/Files/common_8h.md#variable-value) \
	   }; _normal; })
</code></pre>
<p>Convert from a byte array/slice into an array/slice of another type. </p>
<h3 id="define-reverse"><a class="header" href="#define-reverse">define REVERSE</a></h3>
<pre><code class="language-cpp">#define REVERSE(
    SELF
)
	__extension__\
	({ __auto_type _self = &amp;(SELF); \
	   [reverse](/crelude/Files/common_8h.md#function-reverse)(_self, sizeof(*_self-&gt;[value](/crelude/Files/common_8h.md#variable-value))); \
	   *_self; })
</code></pre>
<p>In-place reverse. </p>
<h3 id="define-swap"><a class="header" href="#define-swap">define SWAP</a></h3>
<pre><code class="language-cpp">#define SWAP(
    SELF,
    PIVOT
)
	__extension__\
	({ __auto_type _self = &amp;(SELF); \
	   [swap](/crelude/Files/common_8h.md#function-swap)(_self, (PIVOT), sizeof(*_self-&gt;[value](/crelude/Files/common_8h.md#variable-value))); })
</code></pre>
<h3 id="define-push"><a class="header" href="#define-push">define PUSH</a></h3>
<pre><code class="language-cpp">#define PUSH(
    SELF,
    ELEM
)
	__extension__\
	({ __auto_type           _self = &amp;(SELF); \
	   typeof(*_self-&gt;[value](/crelude/Files/common_8h.md#variable-value)) _elem =  (ELEM); \
	   [push](/crelude/Files/common_8h.md#function-push)(_self, &amp;_elem, sizeof(_elem)); })
</code></pre>
<h3 id="define-pop"><a class="header" href="#define-pop">define POP</a></h3>
<pre><code class="language-cpp">#define POP(
    SELF
)
	__extension__\
	({ __auto_type _self = &amp;(SELF); \
	   (typeof(_self-&gt;[value](/crelude/Files/common_8h.md#variable-value)))[pop](/crelude/Files/common_8h.md#function-pop)(_self, sizeof(*_self-&gt;[value](/crelude/Files/common_8h.md#variable-value))); })
</code></pre>
<h3 id="define-shift"><a class="header" href="#define-shift">define SHIFT</a></h3>
<pre><code class="language-cpp">#define SHIFT(
    SELF
)
	__extension__\
	({ __auto_type _self = &amp;(SELF); \
	   (typeof(_self-&gt;[value](/crelude/Files/common_8h.md#variable-value)))[shift](/crelude/Files/common_8h.md#function-shift)(_self, sizeof(*_self-&gt;[value](/crelude/Files/common_8h.md#variable-value))); })
</code></pre>
<h3 id="define-insert"><a class="header" href="#define-insert">define INSERT</a></h3>
<pre><code class="language-cpp">#define INSERT(
    SELF,
    INDEX,
    ELEM
)
	__extension__\
	({ __auto_type           _self = &amp;(SELF); \
	   typeof(*_self-&gt;[value](/crelude/Files/common_8h.md#variable-value)) _elem =  (ELEM); \
	   [insert](/crelude/Files/common_8h.md#function-insert)(_self, (INDEX), &amp;_elem, sizeof(_elem)); })
</code></pre>
<h3 id="define-extend"><a class="header" href="#define-extend">define EXTEND</a></h3>
<pre><code class="language-cpp">#define EXTEND(
    SELF,
    SLIC
)
	__extension__\
	({ __auto_type _self = &amp;(SELF); \
	   __auto_type _slic =  (SLIC); \
	   [extend](/crelude/Files/common_8h.md#function-extend)(_self, &amp;_slic, sizeof(*[_slic.value](/crelude/Files/common_8h.md#variable-value))); })
</code></pre>
<h3 id="define-splice"><a class="header" href="#define-splice">define SPLICE</a></h3>
<pre><code class="language-cpp">#define SPLICE(
    SELF,
    INDEX,
    SLIC
)
	__extension__\
	({ __auto_type _self = &amp;(SELF); \
	   __auto_type _slic =  (SLIC); \
	   [splice](/crelude/Files/common_8h.md#function-splice)(_self, (INDEX), &amp;_slic, sizeof(*[_slic.value](/crelude/Files/common_8h.md#variable-value))); })
</code></pre>
<h3 id="define-cut"><a class="header" href="#define-cut">define CUT</a></h3>
<pre><code class="language-cpp">#define CUT(
    SELF,
    FROM,
    UPTO
)
	__extension__\
	({ __auto_type _self = &amp;(SELF); \
	   static [GenericSlice](/crelude/Classes/structGenericSlice.md) _cut; \
	   _cut = [cut](/crelude/Files/common_8h.md#function-cut)(_self, (FROM), (UPTO), sizeof(*_self-&gt;[value](/crelude/Files/common_8h.md#variable-value))); \
	   ([u0](/crelude/Files/common_8h.md#typedef-u0) *)&amp;_cut; })
</code></pre>
<h3 id="define-remove"><a class="header" href="#define-remove">define REMOVE</a></h3>
<pre><code class="language-cpp">#define REMOVE(
    SELF,
    INDEX
)
	__extension__\
	({ __auto_type _self = &amp;(SELF); \
	   [usize](/crelude/Files/common_8h.md#typedef-usize) _indx = (INDEX); \
	   [GenericSlice](/crelude/Classes/structGenericSlice.md) _cut \
	       = [cut](/crelude/Files/common_8h.md#function-cut)(_self, _indx, _indx, sizeof(*_self-&gt;[value](/crelude/Files/common_8h.md#variable-value))); \
	   (typeof(_self-&gt;[value](/crelude/Files/common_8h.md#variable-value)))[PTR](/crelude/Files/common_8h.md#define-ptr)(_cut); })
</code></pre>
<h3 id="define-associate"><a class="header" href="#define-associate">define ASSOCIATE</a></h3>
<pre><code class="language-cpp">#define ASSOCIATE(
    SELF,
    KEY,
    VAL
)
	__extension__\
	({ __auto_type _self = &amp;(SELF); \
	   __auto_type _key = (KEY); \
	   __auto_type _val = (VAL); \
	   [associate](/crelude/Files/common_8h.md#function-associate)(_self, &amp;_key, &amp;_val); })
</code></pre>
<h3 id="define-lookup"><a class="header" href="#define-lookup">define LOOKUP</a></h3>
<pre><code class="language-cpp">#define LOOKUP(
    SELF,
    KEY
)
	__extension__\
	({ __auto_type _self = &amp;(SELF); \
	   __auto_type _key = (KEY); \
	   (typeof(_self-&gt;[buckets.value](/crelude/Files/common_8h.md#variable-value)[0].[value](/crelude/Files/common_8h.md#variable-value)) *)[lookup](/crelude/Files/common_8h.md#function-lookup)(_self, &amp;_key); })
</code></pre>
<h3 id="define-drop"><a class="header" href="#define-drop">define DROP</a></h3>
<pre><code class="language-cpp">#define DROP(
    SELF,
    KEY
)
	__extension__\
	({ __auto_type _self = &amp;(SELF); \
	   __auto_type _key = (KEY); \
	   [drop](/crelude/Files/common_8h.md#function-drop)(_self, &amp;_key); })
</code></pre>
<h3 id="define-keys"><a class="header" href="#define-keys">define KEYS</a></h3>
<pre><code class="language-cpp">#define KEYS(
    MAP
)
	__extension__\
	({ __auto_type _map = &amp;(MAP); \
	   static [GenericSlice](/crelude/Classes/structGenericSlice.md) _keys; \
	   _keys = [get_keys](/crelude/Files/common_8h.md#function-get_keys)(_map); \
	   ([u0](/crelude/Files/common_8h.md#typedef-u0) *)&amp;_keys; })
</code></pre>
<h3 id="define-has_key"><a class="header" href="#define-has_key">define HAS_KEY</a></h3>
<pre><code class="language-cpp">#define HAS_KEY(
    MAP,
    KEY
)
	__extension__\
	({ __auto_type _map = &amp;(MAP); \
	   __auto_type _key = (KEY); \
	   [has_key](/crelude/Files/common_8h.md#function-has_key)(_map, &amp;_key); })
</code></pre>
<h3 id="define-append"><a class="header" href="#define-append">define APPEND</a></h3>
<pre><code class="language-cpp">#define APPEND(
    SELF,
    ELEM
)
[PUSH](/crelude/Files/common_8h.md#define-push)(SELF, ELEM)
</code></pre>
<h3 id="define-prepend"><a class="header" href="#define-prepend">define PREPEND</a></h3>
<pre><code class="language-cpp">#define PREPEND(
    SELF,
    ELEM
)
[INSERT](/crelude/Files/common_8h.md#define-insert)(SELF, 0, ELEM)
</code></pre>
<h3 id="define-unshift"><a class="header" href="#define-unshift">define UNSHIFT</a></h3>
<pre><code class="language-cpp">#define UNSHIFT(
    SELF,
    ELEM
)
[PREPEND](/crelude/Files/common_8h.md#define-prepend)(SELF, ELEM)
</code></pre>
<h3 id="define-prefix"><a class="header" href="#define-prefix">define PREFIX</a></h3>
<pre><code class="language-cpp">#define PREFIX(
    SELF,
    SLIC
)
[SPLICE](/crelude/Files/common_8h.md#define-splice)(SELF, 0, SLIC)
</code></pre>
<h3 id="define-head"><a class="header" href="#define-head">define HEAD</a></h3>
<pre><code class="language-cpp">#define HEAD(
    SELF,
    END
)
[SLICE](/crelude/Files/common_8h.md#define-slice)(SELF, 0, END)
</code></pre>
<h3 id="define-tail"><a class="header" href="#define-tail">define TAIL</a></h3>
<pre><code class="language-cpp">#define TAIL(
    SELF,
    BEG
)
[SLICE](/crelude/Files/common_8h.md#define-slice)(SELF, BEG, -1)
</code></pre>
<h3 id="define-first"><a class="header" href="#define-first">define FIRST</a></h3>
<pre><code class="language-cpp">#define FIRST(
    SELF
)
[NTH](/crelude/Files/common_8h.md#define-nth)(SELF, 0)
</code></pre>
<h3 id="define-last"><a class="header" href="#define-last">define LAST</a></h3>
<pre><code class="language-cpp">#define LAST(
    SELF
)
[GET](/crelude/Files/common_8h.md#define-get)(SELF, -1)
</code></pre>
<h3 id="define-qsort"><a class="header" href="#define-qsort">define QSORT</a></h3>
<pre><code class="language-cpp">#define QSORT(
    SELF,
    CMPR
)
	__extension__\
	({ __auto_type _self = (SELF); \
	   qsort([PTR](/crelude/Files/common_8h.md#define-ptr)(_self), [_self.len](/crelude/Files/base64_8h.md#variable-len), sizeof(*[_self.value](/crelude/Files/common_8h.md#variable-value)), CMPR); \
	   _self; })
</code></pre>
<p>Minimal helper/wrapper around in-place <code>qsort</code> for arrays/slices. </p>
<h3 id="define-sort"><a class="header" href="#define-sort">define SORT</a></h3>
<pre><code class="language-cpp">#define SORT(
    SELF,
    SUBJ,
    OTHR,
    ...
)
	__extension__\
	({ int compar_fn_(const [u0](/crelude/Files/common_8h.md#typedef-u0) *SUBJ, const [u0](/crelude/Files/common_8h.md#typedef-u0) *OTHR) __VA_ARGS__ \
	   __auto_type _self = (SELF); \
	   qsort([PTR](/crelude/Files/common_8h.md#define-ptr)(_self), [_self.len](/crelude/Files/base64_8h.md#variable-len), sizeof(*[_self.value](/crelude/Files/common_8h.md#variable-value)), compar_fn_); \
	   _self; })
</code></pre>
<p>Wrapper around in-place <code>qsort</code> for arrays and slices. Creates a nested function within a statement-expression that is defined by the function body passed in as <strong>VA_ARGS</strong> to the macro, which defines the comparison function for the sort. This makes use of two GNU extensions: 'nested functions', and 'statement expressions'. e.g. SORT(arr, self, other, { if ((Struct *)self-&gt;x == (Struct *)other-&gt;x) return 0; if ((Struct *)self-&gt;x &lt; (Struct *)other-&gt;x) return -1; if ((Struct *)self-&gt;x &gt; (Struct *)other-&gt;x) return +1; }); SORT(arr, self, other, { return my_compare(self, other); }); SORT(arr, self, other, CMP((Struct *)self-&gt;x, (Struct *)other-&gt;x)); </p>
<h3 id="define-cmp"><a class="header" href="#define-cmp">define CMP</a></h3>
<pre><code class="language-cpp">#define CMP(
    A,
    B
)
	{ if ((A) &lt;  (B)) return -1; \
	  if ((A) == (B)) return  0; \
	  if ((A) &gt;  (B)) return +1; }
</code></pre>
<p>Function body for comparison of items which have '&gt;', '=' and '&lt;' defined, e.g. int comparef(float a, float b) <a href="/crelude/Files/common_8h.html#define-cmp">CMP(a, b)</a></p>
<h3 id="define-ansi"><a class="header" href="#define-ansi">define ANSI</a></h3>
<pre><code class="language-cpp">#define ANSI(
    CODE
)
&quot;\x1b[&quot; CODE &quot;m&quot;
</code></pre>
<h3 id="define-bold"><a class="header" href="#define-bold">define BOLD</a></h3>
<pre><code class="language-cpp">#define BOLD &quot;1&quot;
</code></pre>
<h3 id="define-faint"><a class="header" href="#define-faint">define FAINT</a></h3>
<pre><code class="language-cpp">#define FAINT &quot;2&quot;
</code></pre>
<h3 id="define-dim"><a class="header" href="#define-dim">define DIM</a></h3>
<pre><code class="language-cpp">#define DIM [FAINT](/crelude/Files/common_8h.md#define-faint)
</code></pre>
<h3 id="define-italic"><a class="header" href="#define-italic">define ITALIC</a></h3>
<pre><code class="language-cpp">#define ITALIC &quot;3&quot;
</code></pre>
<h3 id="define-under"><a class="header" href="#define-under">define UNDER</a></h3>
<pre><code class="language-cpp">#define UNDER &quot;4&quot;
</code></pre>
<h3 id="define-blink"><a class="header" href="#define-blink">define BLINK</a></h3>
<pre><code class="language-cpp">#define BLINK &quot;5&quot;
</code></pre>
<h3 id="define-rapid"><a class="header" href="#define-rapid">define RAPID</a></h3>
<pre><code class="language-cpp">#define RAPID &quot;6&quot;
</code></pre>
<h3 id="define-invert"><a class="header" href="#define-invert">define INVERT</a></h3>
<pre><code class="language-cpp">#define INVERT &quot;7&quot;
</code></pre>
<h3 id="define-hidden"><a class="header" href="#define-hidden">define HIDDEN</a></h3>
<pre><code class="language-cpp">#define HIDDEN &quot;8&quot;
</code></pre>
<h3 id="define-strike"><a class="header" href="#define-strike">define STRIKE</a></h3>
<pre><code class="language-cpp">#define STRIKE &quot;9&quot;
</code></pre>
<h3 id="define-bold_off"><a class="header" href="#define-bold_off">define BOLD_OFF</a></h3>
<pre><code class="language-cpp">#define BOLD_OFF &quot;21&quot;
</code></pre>
<h3 id="define-faint_off"><a class="header" href="#define-faint_off">define FAINT_OFF</a></h3>
<pre><code class="language-cpp">#define FAINT_OFF &quot;22&quot;
</code></pre>
<h3 id="define-italic_off"><a class="header" href="#define-italic_off">define ITALIC_OFF</a></h3>
<pre><code class="language-cpp">#define ITALIC_OFF &quot;23&quot;
</code></pre>
<h3 id="define-under_off"><a class="header" href="#define-under_off">define UNDER_OFF</a></h3>
<pre><code class="language-cpp">#define UNDER_OFF &quot;24&quot;
</code></pre>
<h3 id="define-blink_off"><a class="header" href="#define-blink_off">define BLINK_OFF</a></h3>
<pre><code class="language-cpp">#define BLINK_OFF &quot;25&quot;
</code></pre>
<h3 id="define-rapid_off"><a class="header" href="#define-rapid_off">define RAPID_OFF</a></h3>
<pre><code class="language-cpp">#define RAPID_OFF &quot;26&quot;
</code></pre>
<h3 id="define-invert_off"><a class="header" href="#define-invert_off">define INVERT_OFF</a></h3>
<pre><code class="language-cpp">#define INVERT_OFF &quot;27&quot;
</code></pre>
<h3 id="define-hidden_off"><a class="header" href="#define-hidden_off">define HIDDEN_OFF</a></h3>
<pre><code class="language-cpp">#define HIDDEN_OFF &quot;28&quot;
</code></pre>
<h3 id="define-strike_off"><a class="header" href="#define-strike_off">define STRIKE_OFF</a></h3>
<pre><code class="language-cpp">#define STRIKE_OFF &quot;29&quot;
</code></pre>
<h3 id="define-reset"><a class="header" href="#define-reset">define RESET</a></h3>
<pre><code class="language-cpp">#define RESET &quot;0&quot;
</code></pre>
<h3 id="define-min"><a class="header" href="#define-min">define min</a></h3>
<pre><code class="language-cpp">#define min(
    A,
    B
)
	__extension__({ \
	typeof(A) _a = (A); \
	typeof(B) _b = (B); \
	_a &gt; _b ? _b : _a; })
</code></pre>
<h3 id="define-max"><a class="header" href="#define-max">define max</a></h3>
<pre><code class="language-cpp">#define max(
    A,
    B
)
	__extension__({ \
	typeof(A) _a = (A); \
	typeof(B) _b = (B); \
	_b &gt; _a ? _b : _a; })
</code></pre>
<h3 id="define-deref"><a class="header" href="#define-deref">define deref</a></h3>
<pre><code class="language-cpp">#define deref(
    T,
    PTR,
    ALT
)
	__extension__\
	({ T _alt = (ALT); \
	   *(T *)[or](/crelude/Files/common_8h.md#function-or)([PTR](/crelude/Files/common_8h.md#define-ptr), &amp;_alt); })
</code></pre>
<h3 id="define-wrap"><a class="header" href="#define-wrap">define WRAP</a></h3>
<pre><code class="language-cpp">#define WRAP(
    TYPE,
    VALUE
)
= ((TYPE){ .[value](/crelude/Files/common_8h.md#variable-value) = (VALUE) })
</code></pre>
<p>Wrap value in wrapper struct. </p>
<h3 id="define-unwrap"><a class="header" href="#define-unwrap">define UNWRAP</a></h3>
<pre><code class="language-cpp">#define UNWRAP(
    STRUCTURE
)
(STRUCTURE).[value](/crelude/Files/common_8h.md#variable-value)
</code></pre>
<p>Unwraps pointer/value in sizing wrapper struct. </p>
<h3 id="define-ptr"><a class="header" href="#define-ptr">define PTR</a></h3>
<pre><code class="language-cpp">#define PTR(
    ARR
)
(ARR).[value](/crelude/Files/common_8h.md#variable-value)
</code></pre>
<p>Explicitly only extract pointer from array/slice. </p>
<h3 id="define-free_inside"><a class="header" href="#define-free_inside">define FREE_INSIDE</a></h3>
<pre><code class="language-cpp">#define FREE_INSIDE(
    S
)
[FREE](/crelude/Files/common_8h.md#define-free)((S).[value](/crelude/Files/common_8h.md#variable-value))
</code></pre>
<p>Call to <code>free</code> of inside of slice/array/newtype, etc. </p>
<h3 id="define-init"><a class="header" href="#define-init">define INIT</a></h3>
<pre><code class="language-cpp">#define INIT(
    TYPE,
    ...
)
	{ \
	.[len](/crelude/Files/base64_8h.md#variable-len) = sizeof((TYPE[])__VA_ARGS__)/sizeof(TYPE), \
	.[value](/crelude/Files/common_8h.md#variable-value) = (TYPE[])__VA_ARGS__ \
}
</code></pre>
<p>Initialise sizing wrapper with literal. </p>
<h3 id="define-list"><a class="header" href="#define-list">define LIST</a></h3>
<pre><code class="language-cpp">#define LIST(
    TYPE,
    ...
)
	__extension__({ \
	TYPE _slice; \
	typeof(*[_slice.value](/crelude/Files/common_8h.md#variable-value)) _elem; \
	static typeof(_elem) _list[] = __VA_ARGS__; \
	_slice = ((typeof(_slice)){ \
		.[len](/crelude/Files/base64_8h.md#variable-len) = sizeof(_list)/sizeof(_elem), \
		.[value](/crelude/Files/common_8h.md#variable-value) = _list \
	}); _slice; })
</code></pre>
<p>Can be used to make slices from literal arrays. </p>
<h3 id="define-string"><a class="header" href="#define-string">define STRING</a></h3>
<pre><code class="language-cpp">#define STRING(
    ...
)
	{ \
	.[len](/crelude/Files/base64_8h.md#variable-len) = sizeof(([byte](/crelude/Files/common_8h.md#typedef-byte)[]){ __VA_ARGS__ }) - 1, \
	.[value](/crelude/Files/common_8h.md#variable-value) = ([byte](/crelude/Files/common_8h.md#typedef-byte)[]){ __VA_ARGS__ } \
}
</code></pre>
<p>Initialise sizing wrapper with of string literal. </p>
<h3 id="define-str"><a class="header" href="#define-str">define STR</a></h3>
<pre><code class="language-cpp">#define STR(
    ...
)
(([string](/crelude/Classes/structstring.md))[STRING](/crelude/Files/common_8h.md#define-string)(__VA_ARGS__))
</code></pre>
<h3 id="define-sempty"><a class="header" href="#define-sempty">define SEMPTY</a></h3>
<pre><code class="language-cpp">#define SEMPTY(
    TYPE
)
((TYPE){ .[len](/crelude/Files/base64_8h.md#variable-len) = 0, .[value](/crelude/Files/common_8h.md#variable-value) = [nil](/crelude/Files/common_8h.md#define-nil) })
</code></pre>
<p>Empty slice of certain type. </p>
<h3 id="define-aempty"><a class="header" href="#define-aempty">define AEMPTY</a></h3>
<pre><code class="language-cpp">#define AEMPTY(
    TYPE
)
((TYPE){ .[len](/crelude/Files/base64_8h.md#variable-len) = 0, .cap = 0, .[value](/crelude/Files/common_8h.md#variable-value) = [nil](/crelude/Files/common_8h.md#define-nil) })
</code></pre>
<p>Empty array of certain type. </p>
<h3 id="define-empty"><a class="header" href="#define-empty">define EMPTY</a></h3>
<pre><code class="language-cpp">#define EMPTY(
    TYPE
)
((TYPE){ 0 })
</code></pre>
<p>Empty / zero struct. </p>
<h3 id="define-is_empty"><a class="header" href="#define-is_empty">define IS_EMPTY</a></h3>
<pre><code class="language-cpp">#define IS_EMPTY(
    ARR
)
((ARR).[len](/crelude/Files/base64_8h.md#variable-len) == 0)
</code></pre>
<p>Is array empty? </p>
<h3 id="define-amake"><a class="header" href="#define-amake">define AMAKE</a></h3>
<pre><code class="language-cpp">#define AMAKE(
    TYPE,
    CAP
)
	{ \
	.[len](/crelude/Files/base64_8h.md#variable-len) = 0, \
	.cap = (CAP), \
	.[value](/crelude/Files/common_8h.md#variable-value) = [emalloc](/crelude/Files/common_8h.md#function-emalloc)((CAP), sizeof(TYPE)) \
}
</code></pre>
<p>Heap allocates a variable sized array. </p>
<h3 id="define-anew"><a class="header" href="#define-anew">define ANEW</a></h3>
<pre><code class="language-cpp">#define ANEW(
    VARIABLE,
    CAP
)
(typeof(VARIABLE))[AMAKE](/crelude/Files/common_8h.md#define-amake)(typeof((VARIABLE).[value](/crelude/Files/common_8h.md#variable-value)[0]), CAP)
</code></pre>
<p>Create new array / initialise array from array variable. </p>
<h3 id="define-smake"><a class="header" href="#define-smake">define SMAKE</a></h3>
<pre><code class="language-cpp">#define SMAKE(
    TYPE,
    LEN
)
	{ \
	.[len](/crelude/Files/base64_8h.md#variable-len) = (LEN), \
	.[value](/crelude/Files/common_8h.md#variable-value) = [emalloc](/crelude/Files/common_8h.md#function-emalloc)((LEN), sizeof(TYPE)) \
}
</code></pre>
<p>Heap allocates a constant sized slice type. </p>
<h3 id="define-snew"><a class="header" href="#define-snew">define SNEW</a></h3>
<pre><code class="language-cpp">#define SNEW(
    VARIABLE,
    LEN
)
(typeof(VARIABLE))[SMAKE](/crelude/Files/common_8h.md#define-smake)(typeof((VARIABLE).[value](/crelude/Files/common_8h.md#variable-value)[0]), LEN)
</code></pre>
<p>Create new slice / initialise slice from slice variable. </p>
<h3 id="define-slice"><a class="header" href="#define-slice">define SLICE</a></h3>
<pre><code class="language-cpp">#define SLICE(
    TYPE,
    OBJ,
    START,
    END
)
	((TYPE){ \
	.[len](/crelude/Files/base64_8h.md#variable-len) = ((([isize](/crelude/Files/common_8h.md#typedef-isize))(END) &lt; 0) ? (OBJ).[len](/crelude/Files/base64_8h.md#variable-len) + 1 : 0) + (END) - (START), \
	.[value](/crelude/Files/common_8h.md#variable-value) = (OBJ).[value](/crelude/Files/common_8h.md#variable-value) + (START) \
})
</code></pre>
<p>Take a slice/substring/view of sized type. </p>
<h3 id="define-view"><a class="header" href="#define-view">define VIEW</a></h3>
<pre><code class="language-cpp">#define VIEW(
    TYPE,
    PTR,
    START,
    END
)
	((TYPE){ \
	.[len](/crelude/Files/base64_8h.md#variable-len) = (END) - (START), \
	.[value](/crelude/Files/common_8h.md#variable-value) = ([PTR](/crelude/Files/common_8h.md#define-ptr)) + (START) \
})
</code></pre>
<p>Works like <code>SLICE</code>, but on a pointer instead of an array. </p>
<h3 id="define-symbolic"><a class="header" href="#define-symbolic">define SYMBOLIC</a></h3>
<pre><code class="language-cpp">#define SYMBOLIC(
    STR
)
	(([symbol](/crelude/Classes/structsymbol.md)){ \
	.[hash](/crelude/Files/common_8h.md#variable-hash) = [hash_string](/crelude/Files/common_8h.md#function-hash_string)([STR](/crelude/Files/common_8h.md#define-str)), \
	.[value](/crelude/Files/common_8h.md#variable-value) = [STR](/crelude/Files/common_8h.md#define-str) \
})
</code></pre>
<h3 id="define-symbol_literal"><a class="header" href="#define-symbol_literal">define SYMBOL_LITERAL</a></h3>
<pre><code class="language-cpp">#define SYMBOL_LITERAL(
    STR_LIT
)
	(([symbol](/crelude/Classes/structsymbol.md)){ \
	.[hash](/crelude/Files/common_8h.md#variable-hash) = [hash_string](/crelude/Files/common_8h.md#function-hash_string)([STRING](/crelude/Files/common_8h.md#define-string)(STR_LIT)), \
	.[value](/crelude/Files/common_8h.md#variable-value) = [STRING](/crelude/Files/common_8h.md#define-string)(STR_LIT) \
})
</code></pre>
<h3 id="define-acollect"><a class="header" href="#define-acollect">define ACOLLECT</a></h3>
<pre><code class="language-cpp">#define ACOLLECT(
    T,
    count,
    pointer
)
	((T){ \
	.[len](/crelude/Files/base64_8h.md#variable-len) = count,     \
	.cap = count,     \
	.[value](/crelude/Files/common_8h.md#variable-value) = pointer, \
})
</code></pre>
<p>C array to dynamic array wrapper. </p>
<h3 id="define-scollect"><a class="header" href="#define-scollect">define SCOLLECT</a></h3>
<pre><code class="language-cpp">#define SCOLLECT(
    T,
    count,
    pointer
)
	((T){ \
	.[len](/crelude/Files/base64_8h.md#variable-len) = count,     \
	.[value](/crelude/Files/common_8h.md#variable-value) = pointer, \
})
</code></pre>
<p>C array to slice wrapper. </p>
<h3 id="define-smap"><a class="header" href="#define-smap">define SMAP</a></h3>
<pre><code class="language-cpp">#define SMAP(
    T,
    func,
    list
)
	__extension__({ \
	T _mapped; \
	_mapped = ((T)[SMAKE](/crelude/Files/common_8h.md#define-smake)(typeof(*[_mapped.value](/crelude/Files/common_8h.md#variable-value)), (list).[len](/crelude/Files/base64_8h.md#variable-len))); \
	for ([usize](/crelude/Files/common_8h.md#typedef-usize) _i = 0; _i &lt; (list).[len](/crelude/Files/base64_8h.md#variable-len); ++_i) \
		[_mapped.value](/crelude/Files/common_8h.md#variable-value)[_i] = (func)((list).[value](/crelude/Files/common_8h.md#variable-value)[_i]); \
	_mapped; \
})
</code></pre>
<h3 id="define-amap"><a class="header" href="#define-amap">define AMAP</a></h3>
<pre><code class="language-cpp">#define AMAP(
    T,
    func,
    list
)
	__extension__({ \
	T _mapped; \
	_mapped = ((T)[AMAKE](/crelude/Files/common_8h.md#define-amake)(typeof(*[_mapped.value](/crelude/Files/common_8h.md#variable-value)), (list).[len](/crelude/Files/base64_8h.md#variable-len))); \
	for ([usize](/crelude/Files/common_8h.md#typedef-usize) _i = 0; _i &lt; (list).[len](/crelude/Files/base64_8h.md#variable-len); ++_i, ++[_mapped.len](/crelude/Files/base64_8h.md#variable-len)) \
		[_mapped.value](/crelude/Files/common_8h.md#variable-value)[_i] = (func)((list).[value](/crelude/Files/common_8h.md#variable-value)[_i]); \
	_mapped; \
})
</code></pre>
<h3 id="define-for_each"><a class="header" href="#define-for_each">define FOR_EACH</a></h3>
<pre><code class="language-cpp">#define FOR_EACH(
    ELEM,
    ELEMS
)
	for (struct { typeof(*(ELEMS).[value](/crelude/Files/common_8h.md#variable-value)) item; \
			      typeof((ELEMS).[value](/crelude/Files/common_8h.md#variable-value)) ptr, start; \
				  [usize](/crelude/Files/common_8h.md#typedef-usize) index; \
				  bool first, once; \
				} it = { .item = *(ELEMS).[value](/crelude/Files/common_8h.md#variable-value), \
				         .ptr = (ELEMS).[value](/crelude/Files/common_8h.md#variable-value), \
				         .start = (ELEMS).[value](/crelude/Files/common_8h.md#variable-value), \
				         .index = 0, \
						 .first = true, \
						 .once = true \
				       }; it.once; it.once = false) \
		for (typeof(*(ELEMS).[value](/crelude/Files/common_8h.md#variable-value)) ELEM = *(ELEMS).[value](/crelude/Files/common_8h.md#variable-value); \
		    it.index &lt; (ELEMS).[len](/crelude/Files/base64_8h.md#variable-len); \
			++it.ptr, it.index = (it.ptr - it.start), \
			  it.item = *it.ptr, it.first = false, ELEM = it.item)
</code></pre>
<p>For-each loop, iterates across an array or slice. It creates an <code>it</code> variable, that holds:</p>
<ul>
<li>it.index (index in array);</li>
<li>it.item (current item of array);</li>
<li>it.ptr (pointer to current item in array);</li>
<li>it.first (pointer to frist item in array);</li>
<li>it.once (a bool, true if we are on the first iteration). For example: </li>
</ul>
<pre><code class="language-cpp">newarray(IntArray, int);
IntArray xs = AMAKE(IntArray, 2);

int elem1 = 5;
int elem2 = 3;
sliceof(int) elems = INIT(int, { 6, 9, 1 });

push(&amp;xs, &amp;elem1, sizeof(int));
push(&amp;xs, &amp;elem2, sizeof(int));
extend(&amp;xs, &amp;elems, sizeof(int));

FOR_EACH(x, xs) {
    printf(&quot;xs[%zu] = %d\n&quot;, it.index, x);
}
</code></pre>
<p><em>Filename: .c</em></p>
<p>Will print: </p>
<pre><code class="language-cpp">xs[0] = 5
xs[1] = 3
xs[2] = 6
xs[3] = 9
xs[4] = 1
</code></pre>
<h3 id="define-foreach"><a class="header" href="#define-foreach">define foreach</a></h3>
<pre><code class="language-cpp">#define foreach [FOR_EACH](/crelude/Files/common_8h.md#define-for_each)
</code></pre>
<h2 id="source-code"><a class="header" href="#source-code">Source code</a></h2>
<pre><code class="language-cpp">
#ifndef COMMON_HEADER_
#define COMMON_HEADER_

#undef  _GNU_SOURCE
#define _GNU_SOURCE 1 

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stddef.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;limits.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#ifdef __linux__
    #include &lt;unistd.h&gt;
#endif

/* Default macros */
#ifndef FREE
    #define FREE free
#endif
#ifndef MALLOC
    #define MALLOC malloc
#endif
#ifndef REALLOC
    #define REALLOC realloc
#endif

/* Misc macros */
#define VA_NUM_ARGS_IMPL(_1,_2,_3,_4,_5, N,...) N
#define VA_NUM_ARGS(...) VA_NUM_ARGS_IMPL(__VA_ARGS__, 5, 4, 3, 2, 1)

#define _TSTR(x) #x
#define TSTR(x) _TSTR(x)

#if defined(_MSC_VER) || defined(__INTEL_COMPILER)
    #define DO_PRAGMA(x) __pragma(x)
    #define PRAGMA_NO_WARNING __pragma(warning(push, 0))
    #define PRAGMA_POP_WARNING __pragma(warning(pop))
    #define WARNING(...) __pragma(message(Warning: __VA_ARGS__))
#elif defined(__clang__)
    #define DO_PRAGMA(x) _Pragma(#x)
    #define PRAGMA_NO_WARNING \
        _Pragma(&quot;clang diagnostic push&quot;) \
        _Pragma(&quot;clang diagnostic ignored \&quot;-Wall\&quot;&quot;) \
        _Pragma(&quot;clang diagnostic ignored \&quot;-Wextra\&quot;&quot;) \
        _Pragma(&quot;clang diagnostic ignored \&quot;-Wpedantic\&quot;&quot;)
    #define PRAGMA_POP_WARNING _Pragma(&quot;clang diagnostic pop&quot;)
    #define WARNING(S) DO_PRAGMA(clang warning S)
#elif defined(__GNUC__)
    #define DO_PRAGMA(x) _Pragma(#x)
    // Does not behave as nicely as CLANG version does.
    #define PRAGMA_NO_WARNING \
        _Pragma(&quot;GCC diagnostic push&quot;) \
        _Pragma(&quot;GCC diagnostic ignored \&quot;-Wall\&quot;&quot;) \
        _Pragma(&quot;GCC diagnostic ignored \&quot;-Wextra\&quot;&quot;) \
        _Pragma(&quot;GCC diagnostic ignored \&quot;-Wpedantic\&quot;&quot;)
    #define PRAGMA_POP_WARNING _Pragma(&quot;GCC diagnostic pop&quot;)
    #define WARNING(S) DO_PRAGMA(GCC warning S)
#endif

#define TODO(...) DO_PRAGMA(message(&quot;TODO: &quot; #__VA_ARGS__ \
                            &quot; (&quot; __FILE__ &quot;:&quot; TSTR(__LINE__)&quot;)&quot;))

/* Version number */
#define crelude_V_MAJOR 0
#define crelude_V_MINOR 1
#define crelude_V_PATCH 0

#define crelude_VERSION \
    &quot;v&quot; TSTR(crelude_V_MAJOR) \
    &quot;.&quot; TSTR(crelude_V_MINOR) \
    &quot;.&quot; TSTR(crelude_V_PATCH)

#define ARRAY_REALLOC_FACTOR 1.5

/* Syntax helpers */
#define loop while (1)
#define whilst while
#define unless(cond) if (!(cond))
#define never if (0)
#define always if (1)
#define until(cond) while (!(cond))
// Newtypes and arrays, slices, maps, etc.
#define unqualify(D, T)  typedef D T T
#define record(NAME)     typedef struct _##NAME NAME; struct _##NAME
#define enumerable(NAME) typedef   enum _##NAME NAME;   enum _##NAME
#define overlap(NAME)    typedef  union _##NAME NAME;  union _##NAME
#define newtype(NT, T) typedef struct _##NT { T value; } NT
#define arrayof(T) struct { \
    T (*value); \
    usize len;  \
    usize cap;  \
}
#define newarray(NT, T) typedef arrayof(T) NT
#define sliceof(T) struct { \
    T (*value); \
    usize len;  \
}
#define newslice(NT, T) typedef sliceof(T) NT
#define hashof(T) struct { \
    u64 hash; \
    T value;  \
}
#define newhashable(NT, T) typedef hashof(T) NT
enum HashKeyType {  // Use this to pick a default hash method/function.
    HKT_STRING  = 1 &lt;&lt; 0,
    HKT_RUNIC   = 1 &lt;&lt; 1,
    HKT_CSTRING = 1 &lt;&lt; 2,
    HKT_MEM_SLICE = 1 &lt;&lt; 3, //&lt; can be used for any slice, convert with TO_BYTES(...).
    HKT_RAW_BYTES = 1 &lt;&lt; 4,  //&lt; just hash the raw bytes.
    HKT_SMALL_INTEGER = 1 &lt;&lt; 5  //&lt; integer size ≤ than hash size, just upcast.
}; unqualify(enum, HashKeyType);
#define HASHMAP_LOAD_THRESHOLD 0.85
#define HASHMAP_GROWTH_FACTOR  2
#define newmap(NT, K, V) typedef mapof(K, V) NT
#define mapof(K, V) struct { \
    usize len; \
    arrayof(hashnode(K, V)) buckets; /* a hash value of zero indicates absence. */\
    usize value_size; \
    usize   key_size; \
    usize  node_size; \
    /* offsets of `hashnode` struct. */ \
    usize  hash_offset; \
    usize   key_offset; \
    usize value_offset; \
    usize  next_offset; \
    HashKeyType key_type; /* &lt; how should the hash-function hash the key. */ \
    u64 (*hasher)(const u0 *, usize); \
}
#define hashnode(K, V) struct { \
    hashof(K) key; \
    V value;  /* &lt; value stored.   */ \
    u0 *next; /* &lt; next hash-node. */ \
}
#define MMAKE(K, V, CAP) { \
    .len = 0, \
    .buckets = AMAKE(hashnode(K, V), CAP), \
    .key_size = sizeof(K), \
    .value_size = sizeof(V), \
    .node_size = sizeof(hashnode(K, V)), \
    .hash_offset  = offsetof(hashnode(K, V), key) + offsetof(hashof(K), hash), \
    .key_offset   = offsetof(hashnode(K, V), key) + offsetof(hashof(K), value), \
    .value_offset = offsetof(hashnode(K, V), value), \
    .next_offset  = offsetof(hashnode(K, V), next), \
    .key_type = _Generic(*(K *)NULL, \
        string: HKT_STRING, \
        runic: HKT_RUNIC, \
        byte *: HKT_CSTRING, \
        MemSlice: HKT_MEM_SLICE, \
        char[8]: HKT_SMALL_INTEGER, \
        char[7]: HKT_SMALL_INTEGER, \
        char[6]: HKT_SMALL_INTEGER, \
        char[5]: HKT_SMALL_INTEGER, \
        char[4]: HKT_SMALL_INTEGER, \
        char[3]: HKT_SMALL_INTEGER, \
        char[2]: HKT_SMALL_INTEGER, \
        char[1]: HKT_SMALL_INTEGER, \
        signed char:        HKT_SMALL_INTEGER, \
        signed short:       HKT_SMALL_INTEGER, \
        signed int:         HKT_SMALL_INTEGER, \
        signed long:        HKT_SMALL_INTEGER, \
        signed long long:   HKT_SMALL_INTEGER, \
        unsigned char:      HKT_SMALL_INTEGER, \
        unsigned short:     HKT_SMALL_INTEGER, \
        unsigned int:       HKT_SMALL_INTEGER, \
        unsigned long:      HKT_SMALL_INTEGER, \
        unsigned long long: HKT_SMALL_INTEGER, \
        float:  HKT_SMALL_INTEGER, \
        double: HKT_SMALL_INTEGER, \
        default: HKT_RAW_BYTES), \
    .hasher = _Generic(*(K *)NULL, \
        string: string_hash, \
        runic: runic_hash, \
        byte *: cstring_hash, \
        MemSlice: mem_hash, \
        char[8]: upcast_hash, \
        char[7]: upcast_hash, \
        char[6]: upcast_hash, \
        char[5]: upcast_hash, \
        char[4]: upcast_hash, \
        char[3]: upcast_hash, \
        char[2]: upcast_hash, \
        char[1]: upcast_hash, \
        signed char:        upcast_hash, \
        signed short:       upcast_hash, \
        signed int:         upcast_hash, \
        signed long:        upcast_hash, \
        signed long long:   upcast_hash, \
        unsigned char:      upcast_hash, \
        unsigned short:     upcast_hash, \
        unsigned int:       upcast_hash, \
        unsigned long:      upcast_hash, \
        unsigned long long: upcast_hash, \
        float:  upcast_hash, \
        double: upcast_hash, \
        default: default_hash) \
}
#define MNEW(VARIABLE, CAP) (typeof(VARIABLE))MMAKE( \
    typeof((VARIABLE).buckets.value[0].key.value), \
    typeof((VARIABLE).buckets.value[0].value), \
    CAP)

#define NTH(LIST, N) UNWRAP((LIST))[(N)]
#define GET(LIST, N) __extension__\
    ({ __auto_type _list = (LIST); \
       __auto_type _n = (N); \
       usize _index = _n &lt; 0 ? (usize)(_list.len + _n) : (usize)_n; \
       UNWRAP(_list)[_index]; })
#define SET(LIST, N, V) __extension__\
    ({ __auto_type _list = (LIST); \
       __auto_type _n = (N); \
       usize _index = _n &lt; 0 ? (usize)(_list.len + _n) : (usize)_n; \
       UNWRAP(_list)[_index] = (V); })

#define UNUSED1(z) (void)(z)
#define UNUSED2(y,z) UNUSED1(y),UNUSED1(z)
#define UNUSED3(x,y,z) UNUSED1(x),UNUSED2(y,z)
#define UNUSED4(b,x,y,z) UNUSED2(b,x),UNUSED2(y,z)
#define UNUSED5(a,b,x,y,z) UNUSED2(a,b),UNUSED3(x,y,z)
#define UNUSED_IMPL_(nargs) UNUSED ## nargs
#define UNUSED_IMPL(nargs) UNUSED_IMPL_(nargs)
#define UNUSED(...) UNUSED_IMPL(VA_NUM_ARGS(__VA_ARGS__))(__VA_ARGS__)

#define NO_ERROR EXIT_SUCCESS
#define OK EXIT_SUCCESS
#define OKAY EXIT_SUCCESS
#define FAIL EXIT_FAILURE

#define NOOP ((void)0)
#define nil ((void *)NULL)

#define FLOOR(T, N) __extension__\
    ({ typeof(N) _n = (N); \
       (T)_n - (_n &lt; 0 ? 1 : 0); })
#define CEIL(T, N) __extension__\
    ({ typeof(N) _n = (N); \
       (T)_n + (_n &lt; 0 ? 0 : 1); })

/* Types */
newtype(atomic_t, int);

typedef void u0;
#define UNIT ;

typedef   signed int ierr;
typedef unsigned int uerr;  
typedef unsigned long uword;  
typedef   signed long iword;  
#define WORD_SIZE sizeof(long)

typedef unsigned int ufast;
typedef   signed int ifast;

typedef ptrdiff_t isize;
typedef    size_t usize; 

typedef  intptr_t iptr;
typedef uintptr_t uptr; 

typedef  intmax_t imax;
typedef uintmax_t umax;

typedef unsigned char umin;
typedef   signed char imin;

_Static_assert(sizeof(umin) == 1 &amp;&amp; sizeof(imin) == 1,
               &quot;`umin` and `imin` must have size one (1).&quot;);

#define __UCHAR8__ char
#if (CHAR_BIT == 8)
    typedef   signed char i8;
    typedef unsigned char u8;

    #if (CHAR_MIN &lt; 0)
        WARNING(&quot;Crelude works best with -funsigned-char.&quot;)
        #undef  __UCHAR8__
        #define __UCHAR8__ unsigned char
    #endif
#else
    typedef  __int8_t i8;
    typedef __uint8_t u8;

    #undef  __UCHAR8__
    #define __UCHAR8__ __uint8_t;
#endif

#ifndef IMPLEMENTATION
    typedef __UCHAR8__ byte;
#else
    typedef __uint8_t byte;  
#endif

typedef  __int16_t i16;
typedef __uint16_t u16;

typedef  __int32_t i32;
typedef __uint32_t u32;

typedef u32 rune;

#if (__LONG_WIDTH__ == 64)
    typedef   signed long i64;
    typedef unsigned long u64;
#elif (__LONG_LONG_WIDTH__ == 64)
    typedef   signed long long i64;
    typedef unsigned long long u64;
#else
    typedef  __int64_t i64;
    typedef __uint64_t u64;
#endif

#ifdef __SIZEOF_INT128__
    typedef  __int128_t i128;
    typedef __uint128_t u128;
#endif

#define   _FLOAT_BIT (__SIZEOF_FLOAT__       * CHAR_BIT)
#define  _DOUBLE_BIT (__SIZEOF_DOUBLE__      * CHAR_BIT)
#define _LDOUBLE_BIT (__SIZEOF_LONG_DOUBLE__ * CHAR_BIT)

#ifdef __STDC_IEC_559__
    typedef  float f32;
    typedef double f64;
#else
    #if _FLOAT_BIT == 32
        typedef float f32;
    #endif
    #if _DOUBLE_BIT == 64
        typedef double f64;
    #endif
#endif

#if (_LDOUBLE_BIT == 80)
    typedef long double f80;
#elif (_LDOUBLE_BIT == 128)
    typedef long double f128;
#endif

newarray(GenericArray, u0);
newarray(MemArray, umin);
newslice(GenericSlice, u0);
newslice(MemSlice, umin);
newmap(GenericMap, u0 *, u0 *);

newslice(string, byte);
newslice(runic, rune);

newarray(StringBuilder, byte);
newarray(RunicBuilder, rune);

newhashable(symbol, string);

/* Common Constants */
static const ierr NUL = 0;
static const byte NUL_BYTE = '\0';
static const string NUL_STRING = { .len = 0, .value = (byte *)&amp;NUL_BYTE };
static const iword ZERO = 0;

/* Common Functions */
extern u0 panic(const byte *, ...) __attribute__((noreturn));
extern u0 *or(const u0 *nullable, const u0 *nonnull);
extern bool is_zero(imax);
extern bool is_zerof(f64);
extern bool is_zeroed(u0 *, usize);
extern u0 zero(u0 *blk, usize width);
extern u0 *emalloc(usize, usize);
extern u0 reverse(u0 *self, usize width);
extern MemSlice reverse_endianness(MemSlice bytes);
bool is_little_endian(void);
u128 big_endian(umin *start, usize bytes);
extern u0 swap(u0 *self, usize pivot, usize width);
extern u0 memswap(umin *a, umin *b, usize bytes);
extern usize resize(u0 *self, usize cap, usize width);
extern usize grow(u0 *self, usize count, usize width);
extern u0 *get(u0 *self, usize index, usize width);
extern u0 *set(u0 *self, usize index, const u0 *elem, usize width);
extern usize push(u0 *self, const u0 *element, usize width);
extern u0 *pop(u0 *self, usize width);
extern u0 *shift(u0 *self, usize width);
extern usize insert(u0 *self, usize index, const u0 *element, usize width);
extern usize extend(u0 *self, const u0 *slice, usize width);
extern usize splice(u0 *self, usize index, const u0 *slice, usize width);
//           along with the number of removed bytes (`len` of slice).
extern GenericSlice cut(u0 *self, usize from, isize upto, usize width);
extern usize null(u0 *self, usize width);
extern string from_cstring(const byte *);
extern bool string_eq(const string, const string);
extern i16 string_cmp(const string, const string);
extern i16 string_ncmp(const string, const string, usize n);
extern u64 hash_string(const string);
extern u64 hash_bytes(const MemSlice);
extern u0 associate(u0 *self, const u0 *key, const u0 *value);
extern u0 *lookup(u0 *self, const u0 *key);
extern bool drop(u0 *self, const u0 *key);
extern GenericSlice get_keys(u0 *self);
extern bool has_key(u0 *self, u0 *key);
extern u0 empty_map(u0 *self);
extern bool is_empty_map(u0 *self);
extern u0 free_map(u0 *self);
extern usize init_hashnode(u0 *, const u0 *, u64, const u0 *, const u0 *);
extern u0 dump_hashmap(u0 *self, byte *key_formatter, byte *value_formatter);

/* Common Macros */

#define COPY(SELF) __extension__\
    ({ __auto_type _self = (SELF); \
       __auto_type _copy = _self; \
       PTR(_copy) = emalloc(_self.len, sizeof(*PTR(_self))); \
       memcpy(PTR(_copy), PTR(_self), sizeof(*PTR(_copy)) * _copy.len); \
       _copy; })

#define TO_BYTES(SELF) __extension__\
    ({ __auto_type _self = (SELF); \
       MemSlice _bytes = { \
          .len = _self.len * sizeof(*_self.value), \
          .value = (umin *)_self.value \
       }; _bytes; })

#define FROM_BYTES(T, SELF) __extension__\
    ({ __auto_type _self = (SELF); \
       T _normal = { \
          .len = _self.len / sizeof(*_self.value), \
          .value = (u0 *)_self.value \
       }; _normal; })

// ---
// Macros for array functions to avoid use of `sizeof(T)` everywhere.
// These macros do the referencing and void-pointer casting for you, and thus
// let you use non-LVALUES as input (except SELF, SELF must sill be an LVALUE).
// ---

#define REVERSE(SELF) __extension__\
    ({ __auto_type _self = &amp;(SELF); \
       reverse(_self, sizeof(*_self-&gt;value)); \
       *_self; })

#define SWAP(SELF, PIVOT) __extension__\
    ({ __auto_type _self = &amp;(SELF); \
       swap(_self, (PIVOT), sizeof(*_self-&gt;value)); })

#define PUSH(SELF, ELEM) __extension__\
    ({ __auto_type           _self = &amp;(SELF); \
       typeof(*_self-&gt;value) _elem =  (ELEM); \
       push(_self, &amp;_elem, sizeof(_elem)); })

#define POP(SELF) __extension__\
    ({ __auto_type _self = &amp;(SELF); \
       (typeof(_self-&gt;value))pop(_self, sizeof(*_self-&gt;value)); })

#define SHIFT(SELF) __extension__\
    ({ __auto_type _self = &amp;(SELF); \
       (typeof(_self-&gt;value))shift(_self, sizeof(*_self-&gt;value)); })

#define INSERT(SELF, INDEX, ELEM) __extension__\
    ({ __auto_type           _self = &amp;(SELF); \
       typeof(*_self-&gt;value) _elem =  (ELEM); \
       insert(_self, (INDEX), &amp;_elem, sizeof(_elem)); })

#define EXTEND(SELF, SLIC) __extension__\
    ({ __auto_type _self = &amp;(SELF); \
       __auto_type _slic =  (SLIC); \
       extend(_self, &amp;_slic, sizeof(*_slic.value)); })

#define SPLICE(SELF, INDEX, SLIC) __extension__\
    ({ __auto_type _self = &amp;(SELF); \
       __auto_type _slic =  (SLIC); \
       splice(_self, (INDEX), &amp;_slic, sizeof(*_slic.value)); })

#define CUT(SELF, FROM, UPTO) __extension__\
    ({ __auto_type _self = &amp;(SELF); \
       static GenericSlice _cut; \
       _cut = cut(_self, (FROM), (UPTO), sizeof(*_self-&gt;value)); \
       (u0 *)&amp;_cut; })

#define REMOVE(SELF, INDEX) __extension__\
    ({ __auto_type _self = &amp;(SELF); \
       usize _indx = (INDEX); \
       GenericSlice _cut \
           = cut(_self, _indx, _indx, sizeof(*_self-&gt;value)); \
       (typeof(_self-&gt;value))PTR(_cut); })

/* macros for hash-tables (maps) */
#define ASSOCIATE(SELF, KEY, VAL) __extension__\
    ({ __auto_type _self = &amp;(SELF); \
       __auto_type _key = (KEY); \
       __auto_type _val = (VAL); \
       associate(_self, &amp;_key, &amp;_val); })

#define LOOKUP(SELF, KEY) __extension__\
    ({ __auto_type _self = &amp;(SELF); \
       __auto_type _key = (KEY); \
       (typeof(_self-&gt;buckets.value[0].value) *)lookup(_self, &amp;_key); })

#define DROP(SELF, KEY) __extension__\
    ({ __auto_type _self = &amp;(SELF); \
       __auto_type _key = (KEY); \
       drop(_self, &amp;_key); })

#define KEYS(MAP) __extension__\
    ({ __auto_type _map = &amp;(MAP); \
       static GenericSlice _keys; \
       _keys = get_keys(_map); \
       (u0 *)&amp;_keys; })

#define HAS_KEY(MAP, KEY) __extension__\
    ({ __auto_type _map = &amp;(MAP); \
       __auto_type _key = (KEY); \
       has_key(_map, &amp;_key); })

// Some aliases and shortcuts:
#define APPEND(SELF, ELEM) PUSH(SELF, ELEM)
#define PREPEND(SELF, ELEM) INSERT(SELF, 0, ELEM)
#define UNSHIFT(SELF, ELEM) PREPEND(SELF, ELEM)
#define PREFIX(SELF, SLIC) SPLICE(SELF, 0, SLIC)
#define HEAD(SELF, END) SLICE(SELF, 0, END)
#define TAIL(SELF, BEG) SLICE(SELF, BEG, -1)
#define FIRST(SELF) NTH(SELF, 0)
#define LAST(SELF) GET(SELF, -1)

#define QSORT(SELF, CMPR) __extension__\
    ({ __auto_type _self = (SELF); \
       qsort(PTR(_self), _self.len, sizeof(*_self.value), CMPR); \
       _self; })

#define SORT(SELF, SUBJ, OTHR, ...) __extension__\
    ({ int compar_fn_(const u0 *SUBJ, const u0 *OTHR) __VA_ARGS__ \
       __auto_type _self = (SELF); \
       qsort(PTR(_self), _self.len, sizeof(*_self.value), compar_fn_); \
       _self; })

#define CMP(A, B) \
    { if ((A) &lt;  (B)) return -1; \
      if ((A) == (B)) return  0; \
      if ((A) &gt;  (B)) return +1; }

// --- ANSI colour codes. ---

#define ANSI(CODE) &quot;\x1b[&quot; CODE &quot;m&quot;
#define BOLD   &quot;1&quot;
#define FAINT  &quot;2&quot;
#define DIM FAINT
#define ITALIC &quot;3&quot;
#define UNDER  &quot;4&quot;
#define BLINK  &quot;5&quot;
#define RAPID  &quot;6&quot;
#define INVERT &quot;7&quot;
#define HIDDEN &quot;8&quot;
#define STRIKE &quot;9&quot;
#define BOLD_OFF   &quot;21&quot;  // Or sometimes, double-underline...
#define FAINT_OFF  &quot;22&quot;
#define ITALIC_OFF &quot;23&quot;
#define UNDER_OFF  &quot;24&quot;
#define BLINK_OFF  &quot;25&quot;
#define RAPID_OFF  &quot;26&quot;
#define INVERT_OFF &quot;27&quot;
#define HIDDEN_OFF &quot;28&quot;
#define STRIKE_OFF &quot;29&quot;
#define RESET &quot;0&quot;

#define min(A, B) __extension__({ \
    typeof(A) _a = (A); \
    typeof(B) _b = (B); \
    _a &gt; _b ? _b : _a; })
#define max(A, B) __extension__({ \
    typeof(A) _a = (A); \
    typeof(B) _b = (B); \
    _b &gt; _a ? _b : _a; })

#define deref(T, PTR, ALT) __extension__\
    ({ T _alt = (ALT); \
       *(T *)or(PTR, &amp;_alt); })

#define WRAP(TYPE, VALUE) = ((TYPE){ .value = (VALUE) })
#define UNWRAP(STRUCTURE) (STRUCTURE).value
#define PTR(ARR) (ARR).value
#define FREE_INSIDE(S) FREE((S).value)
#define INIT(TYPE, ...) { \
    .len = sizeof((TYPE[])__VA_ARGS__)/sizeof(TYPE), \
    .value = (TYPE[])__VA_ARGS__ \
}
#define LIST(TYPE, ...) __extension__({ \
    TYPE _slice; \
    typeof(*_slice.value) _elem; \
    static typeof(_elem) _list[] = __VA_ARGS__; \
    _slice = ((typeof(_slice)){ \
        .len = sizeof(_list)/sizeof(_elem), \
        .value = _list \
    }); _slice; })

#define STRING(...) { \
    .len = sizeof((byte[]){ __VA_ARGS__ }) - 1, \
    .value = (byte[]){ __VA_ARGS__ } \
}

#define STR(...) ((string)STRING(__VA_ARGS__))

#define SEMPTY(TYPE) ((TYPE){ .len = 0, .value = nil })
#define AEMPTY(TYPE) ((TYPE){ .len = 0, .cap = 0, .value = nil })
#define EMPTY(TYPE) ((TYPE){ 0 })

#define IS_EMPTY(ARR) ((ARR).len == 0)

#define AMAKE(TYPE, CAP) { \
    .len = 0, \
    .cap = (CAP), \
    .value = emalloc((CAP), sizeof(TYPE)) \
}
#define ANEW(VARIABLE, CAP) (typeof(VARIABLE))AMAKE(typeof((VARIABLE).value[0]), CAP)

#define SMAKE(TYPE, LEN) { \
    .len = (LEN), \
    .value = emalloc((LEN), sizeof(TYPE)) \
}
#define SNEW(VARIABLE, LEN) (typeof(VARIABLE))SMAKE(typeof((VARIABLE).value[0]), LEN)

#define SLICE(TYPE, OBJ, START, END) ((TYPE){ \
    .len = (((isize)(END) &lt; 0) ? (OBJ).len + 1 : 0) + (END) - (START), \
    .value = (OBJ).value + (START) \
})

#define VIEW(TYPE, PTR, START, END) ((TYPE){ \
    .len = (END) - (START), \
    .value = (PTR) + (START) \
})

#define SYMBOLIC(STR) ((symbol){ \
    .hash = hash_string(STR), \
    .value = STR \
})

#define SYMBOL_LITERAL(STR_LIT) ((symbol){ \
    .hash = hash_string(STRING(STR_LIT)), \
    .value = STRING(STR_LIT) \
})

#define ACOLLECT(T, count, pointer) ((T){ \
    .len = count,     \
    .cap = count,     \
    .value = pointer, \
})

#define SCOLLECT(T, count, pointer) ((T){ \
    .len = count,     \
    .value = pointer, \
})

#define SMAP(T, func, list) __extension__({ \
    T _mapped; \
    _mapped = ((T)SMAKE(typeof(*_mapped.value), (list).len)); \
    for (usize _i = 0; _i &lt; (list).len; ++_i) \
        _mapped.value[_i] = (func)((list).value[_i]); \
    _mapped; \
})

#define AMAP(T, func, list) __extension__({ \
    T _mapped; \
    _mapped = ((T)AMAKE(typeof(*_mapped.value), (list).len)); \
    for (usize _i = 0; _i &lt; (list).len; ++_i, ++_mapped.len) \
        _mapped.value[_i] = (func)((list).value[_i]); \
    _mapped; \
})

#define FOR_EACH(ELEM, ELEMS) \
    for (struct { typeof(*(ELEMS).value) item; \
                  typeof((ELEMS).value) ptr, start; \
                  usize index; \
                  bool first, once; \
                } it = { .item = *(ELEMS).value, \
                         .ptr = (ELEMS).value, \
                         .start = (ELEMS).value, \
                         .index = 0, \
                         .first = true, \
                         .once = true \
                       }; it.once; it.once = false) \
        for (typeof(*(ELEMS).value) ELEM = *(ELEMS).value; \
            it.index &lt; (ELEMS).len; \
            ++it.ptr, it.index = (it.ptr - it.start), \
              it.item = *it.ptr, it.first = false, ELEM = it.item)

#define foreach FOR_EACH

/* static functions */
/* |- default hash functions */

 __attribute__((unused))
static u64 string_hash(const u0 *key, usize _)
{
    UNUSED(_);
    return hash_string(*(string *)key);
}

 __attribute__((unused))
static u64 runic_hash(const u0 *key, usize _)
{
    UNUSED(_);
    runic runes = *(runic *)key;
    return hash_bytes(TO_BYTES(runes));
}

 __attribute__((unused))
static u64 mem_hash(const u0 *key, usize _)
{
    UNUSED(_);
    return hash_bytes(*(MemSlice *)key);
}

 __attribute__((unused))
static u64 upcast_hash(const u0 *key, usize size)
{
    u64 hash = 0;
    memcpy(&amp;hash, key, size);
    return hash;  // no hashing, just cast the key to a u64.
}

 __attribute__((unused))
static u64 cstring_hash(const u0 *key, usize _)
{
    UNUSED(_);
    return hash_string(from_cstring(*(byte **)key));
}

 __attribute__((unused))
static u64 default_hash(const u0 *key, usize size)
{  // just hashes the plain raw bytes.
    return hash_bytes(VIEW(MemSlice, (umin *)key, 0, size));
}

/* Only define a `main` if ENTRY_FUNCTION is defined */
#ifdef ENTRY_FUNCTION
    newslice(Arguments, string);
    newslice(CArguments, const char *);

    ierr (ENTRY_FUNCTION)(Arguments);

    ierr main(ifast argc, const char **argv)
    {
        Arguments args;
        ierr res;

        args = SMAP(Arguments,
            from_cstring, SCOLLECT(CArguments, argc, argv));
        res = (ENTRY_FUNCTION)(args);

        free(UNWRAP(args));
        return res;
    }
#endif

#endif
</code></pre>
<hr />
<p>Updated on 23 August 2022 at 00:54:19 UTC</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../Files/common_8c.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../Files/io_8c.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../Files/common_8c.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../Files/io_8c.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
